
// Material can be opaque, alpha-blended or additive (defined within lit-shader code)
#define JM_BlendMode JM_Blend_Opaque

// Here are a few per-vertex inputs that are optional:
#define JM_VertexInputOptionalFields (JM_CanDiscard | JM_UseVertexColor)
// Avaliable flags are as follows:
// JM_CanDiscard - Allows fragment discard when JM_Init fails;
// JM_UseObjectId - Exposes JM_ObjectIndex through JM_VertexInput
// JM_UsePerVertexTilingAndOffset - Exposes JM_ObjectTilingAndOffset through JM_VertexInput
// JM_UseVertexColor - Exposes JM_VertexColor through JM_VertexInput


// Each material can define it's properties like this:
#pragma JM_MaterialPropety ValueType0 propetyName0;
#pragma JM_MaterialPropety ValueType1 propetyName1;
// etc...
#pragma JM_MaterialPropety ValueTypeN propetyNameN;
// ValueType can be any primitive type, structure, buffer or sampler; 
// preprocessor and shading models should take responsibility of exposing everything as options to all the Material-defined functions


// Fixed vertex input for all types:
struct JM_VertexInput {
	vec3 position;			// JM_VertexPosition
	vec3 normal;			// JM_VertexNormal
	vec2 uv;				// JM_VertexUV

	mat4 transform;			// JM_ObjectTransform;

#if (JM_VertexInputOptionalFields & JM_UseObjectId) != 0
	uint objectId;			// JM_ObjectIndex (probably optional?)
#endif

#if (JM_VertexInputOptionalFields & JM_UsePerVertexTilingAndOffset) != 0
	vec4 tilingAndOffset;	// JM_ObjectTilingAndOffset (probably optional?)
#endif

#if (JM_VertexInputOptionalFields & JM_UseVertexColor) != 0
	vec4 vertexColor;		// JM_VertexColor (probably optional?)
#endif
};

// Fixed light info for all types:
struct JM_BrdfQuery {
	vec3 lightDirection;	// Fragment-to-light direction
	vec3 viewDelta;			// Fragment-to-view/observer direction, multiplied by distance
	vec3 color;				// Photon color/energy per-channel
};

// Fixed structure for all types:
struct JM_BounceSample {
	vec3 direction;			// Fragment-to-reflection-source direction
	mat3 colorTransform;	// colorTransform * JM_BrdfQuery.color will be assumed to be reflected color, without re-invoking JM_EvaluateBrdf when calculating reflections
};

// Has to be defined within material source:
struct JM_FragmentData {
	// Required fields:
	vec3 position; 			// World-space position

	// Any other shader-defined data goes here...
};

// Auto-generated by preprocessor:
JM_FragmentData mix(JM_FragmentData a, JM_FragmentData b);


// Has to be defined within material source:
struct JM_ShadingState {
	// Required fields:
	vec3 normal; 			// World-space normal
	float roughness;		// [0.0 - 1.0]

	// Any other shader-defined data goes here...
};



// Has to be defined within material source:
JM_FragmentData JM_EvaluateVertex(in const JM_VertexInput vertexInput) {
	// User-Defined implementation...
}

// Has to be defined within material source:
bool JM_Init(in JM_FragmentData fragmentInput, out JM_ShadingState state) {
	// User-Defined implementation...
	return trueIfFragmentShouldNotBeDiscarded; // (false value may be ignored if JM_canDiscard is not set to true)
}

#if JM_BlendMode != JM_Blend_Opaque
// Has to be defined within material source:
float JM_Opacity(inout JM_ShadingState state) {
	// User-Defined implementation...
}
#endif

// Has to be defined within material source:
vec3 JM_Emission(inout JM_ShadingState state, in const vec3 viewDelta) {
	// User-Defined implementation for unlit color emission...
}

// Has to be defined within material source:
vec3 JM_EvaluateBrdf(inout JM_ShadingState state, in const JM_BrdfQuery query) {
	// User-Defined implementation...
}

// Has to be defined within material source:
JM_BounceSample JM_RequestBounceSample(inout JM_ShadingState state, in const vec3 viewDelta) {
	// User-Defined implementation...
}
