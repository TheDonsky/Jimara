#include "PBR.glh"

// Expose Editor name and discription:
#pragma JM_MaterialPath(name = "PBR Color", path = "Jimara/PBR/PBR Color", hint = "Simplest opaque PBR shader without textures");

// We blend as opaque:
#pragma JM_BlendMode JM_Blend_Opaque

// Flags:
#pragma JM_MaterialFlags 0

// Settings:
#pragma JM_MaterialProperty(alias = "Albedo", hint = "Main color of the material", default = { 1.0f, 1.0f, 1.0f }, color) vec3 albedo;
#pragma JM_MaterialProperty(alias = "Metalness", hint = "Tells if the material is metallic or dielectric", min = 0.0f, max = 1.0f) float metalness;
#pragma JM_MaterialProperty(alias = "Roughness", hint = "Tells how rough the material surface is", min = 0.0f, max = 1.0f) float roughness;

// Fragment input: 
#pragma JM_FragmentField vec3 normal;
#pragma JM_FragmentField vec2 uv;

#ifdef JM_ShaderStage

#define JM_ShadingState Jimara_PBR_Fragment
#pragma JM_ShadingStateSize Jimara_PBR_Fragment_Size;

JM_FragmentData JM_EvaluateVertex(in const JM_VertexInput vertexInput, in const JM_MaterialProperties materialProperties) {
	JM_FragmentData fragment;
	fragment.JM_Position = (vertexInput.transform * vec4(vertexInput.position, 1.0)).xyz;
	fragment.normal = (vertexInput.transform * vec4(vertexInput.normal, 0.0)).xyz;
	fragment.uv = vertexInput.uv;
	return fragment;
}

bool JM_Init(in const JM_FragmentData fragmentInput, in const JM_MaterialProperties materialProperties, out JM_ShadingState state) {
	state.position = fragmentInput.JM_Position;
	state.normal = fragmentInput.normal;
	state.albedo = materialProperties.albedo;
	state.metalness = materialProperties.metalness;
	state.roughness = materialProperties.roughness;
	return true;
}

vec3 JM_Emission(inout JM_ShadingState state, in const vec3 viewDelta) {
	return vec3(0.0, 0.0, 0.0);
}

vec3 JM_EvaluateBrdf(inout JM_ShadingState state, in const JM_BrdfQuery query) {
	return Jimara_PBR_BRDF(state, query);
}

bool JM_RequestBounceSample(inout JM_ShadingState state, in const vec3 viewDelta, out JM_BounceSample requestedSample) {
	return Jimara_PBR_RequestBounceSample(state, viewDelta, requestedSample);
}

#else

// Fragment shader input:
struct Jimara_FragmentInput {
	vec3 position;
	vec3 normal;
	vec2 uv;
};


/** ############################################ VERTEX SHADER: ############################################ */
#ifdef JIMARA_VERTEX_SHADER

// Vertex input:
layout(location = 0) in vec3 vertPosition;
layout(location = 1) in vec3 vertNormal;
layout(location = 2) in vec2 vertUV;

// Instance input:
layout(location = 3) in mat4 localTransform;

Jimara_FragmentInput Jimara_CalculateFragmentInput() {
	vec4 position = localTransform * vec4(vertPosition, 1.0f);
	Jimara_FragmentInput fragment;
	fragment.position = (position).xyz;
	fragment.normal = (localTransform * vec4(vertNormal, 0.0f)).xyz;
	fragment.uv = vertUV;
	return fragment;
}


#else
/** ########################################### FRAGMENT SHADER: ########################################### */
#ifdef JIMARA_FRAGMENT_SHADER

// Texture sampler:
layout(set = MATERIAL_BINDING_SET_ID, binding = 0) uniform Settings {
	vec3 albedo;
	float metalness;
	float roughness;
} settings;

// Gbuffer:
struct Jimara_GeometryBuffer {
	vec3 position;
	vec3 normal;
	vec3 albedo;
	float metalness;
	float roughness;
	vec3 viewPosition;
	vec4 pixelColor;
};

mat4 Jimara_ViewPose();

Jimara_GeometryBuffer Jimara_BuildGeometryBuffer(in Jimara_FragmentInput fragment) {
	return Jimara_GeometryBuffer(
		fragment.position, 
		fragment.normal,
		settings.albedo,
		settings.metalness,
		settings.roughness,
		Jimara_ViewPose()[3].rgb,
		vec4(0.0, 0.0, 0.0, 1.0));
}

void Jimara_IlluminateFragment(in Photon photon, inout Jimara_GeometryBuffer gbuffer) {
	gbuffer.pixelColor.rgb += Jimara_PBR_BRDF(
		Jimara_PBR_Fragment(
			gbuffer.position, 
			gbuffer.normal,
			gbuffer.albedo,
			gbuffer.metalness,
			gbuffer.roughness),
		photon, gbuffer.viewPosition);
}

#define JIMARA_OPAQUE_LIT_SHADER

#endif
#endif
#endif
