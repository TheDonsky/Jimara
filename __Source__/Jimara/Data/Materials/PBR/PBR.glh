
#ifndef JIMARA_PBR_HEADER
#define JIMARA_PBR_HEADER
#include "../../../Math/Math.glh"
#include "../../../Environment/Rendering/Algorithms/Random/Jimara_RNG.glh"
/* PBR implementation "heavily inspired" by tutorial from https://learnopengl.com/PBR/Theory */


/// <summary>
/// PBR Fragment descriptor
/// </summary>
struct Jimara_PBR_Fragment {
	/// <summary> World-space position of the fragment </summary>
	vec3 position;
	
	/// <summary> World-space normal of the fragment (has to be normalized) </summary>
	vec3 normal;
	
	/// <summary> Albedo/Base color </summary>
	vec3 albedo;
	
	/// <summary> 'Metalness' value ([0 - 1] range) </summary>
	float metalness;
	
	/// <summary> Surface roughness ([0 - 1] range) </summary>
	float roughness;
};

/// <summary> sizeof(Jimara_PBR_Fragment) + padding </summary>
#define Jimara_PBR_Fragment_Size 64

/// <summary> NDF becomes numerically unstable when roughness is very small. This constant 'caps' the calculations to avoid infinities. </summary>
#define Jimara_PBR_MinNdfRoughness 0.00001


/// <summary>
/// Calculates bidirectional reflective distribution function of a single photon cast on a PBR fragment without clamping and/or multiplying by view-cosine.
/// </summary>
/// <param name="fragment"> PBR Fragment descriptor </param>
/// <param name="photonOrigin"> Incoming photon origin </param>
/// <param name="photonType"> Incoming photon type </param>
/// <param name="viewPosition"> Viewport/Camera position </param>
/// <param name="unclampedColor"> Evaluated color </param>
/// <param name="viewCosine"> dot(fragment.normal, viewDirection) </param>
void Jimara_PBR_Eval(
	in const Jimara_PBR_Fragment fragment, in const vec3 photonOrigin, in const uint photonType, in const vec3 viewPosition,
	out vec3 unclampedColor, out float viewCosine) {

	// Calculate light & camera directions, alongside their mid-dir
	const vec3 lightDirection = normalize(photonOrigin - fragment.position);
	const vec3 viewDirection = normalize(viewPosition - fragment.position);
	const vec3 halfWayDir = normalize(lightDirection + viewDirection);

	// Clamped cosines:
	const float lightCosine = max(dot(fragment.normal, lightDirection), 0.0);
	viewCosine = max(dot(fragment.normal, viewDirection), 0.0);
	const float halfWayCosine = max(dot(fragment.normal, halfWayDir), 0.0);
	
	// Common variables:
	const vec3 f0 = mix(vec3(0.04), fragment.albedo, fragment.metalness);
	#define Jimara_PBR_FresnelSchlick_ROUGHNESS (f0 + (max(vec3(1.0 - fragment.roughness), f0) - f0) * pow(1.0 - viewCosine, 5.0))

	// Special cases for the IBL.... (Let us trust compiler optimizations to simplify the code for special cases)
	if ((photonType & Photon_Type_DiffuseIrradiance) == Photon_Type_DiffuseIrradiance) {
		viewCosine = 1.0;
		unclampedColor = min(1.0 - Jimara_PBR_FresnelSchlick_ROUGHNESS, 1.0) * fragment.albedo;
		return;
	}
	else if ((photonType & Photon_Type_SpecularIrradiance) == Photon_Type_SpecularIrradiance) {
		const vec2 envBRDF = texture(jimara_BindlessTextures[nonuniformEXT(Jimara_BRDF_IntegrationMapId)],
			vec2(viewCosine, fragment.roughness)).rg;
		viewCosine = 1.0;
		unclampedColor = min(Jimara_PBR_FresnelSchlick_ROUGHNESS * envBRDF.x + envBRDF.y, 1.0);
		return;
	}
	#undef Jimara_PBR_FresnelSchlick_ROUGHNESS

	// Normal distribution function:
	float ndf;
	{
		float roughnessSQR = max(fragment.roughness * fragment.roughness, Jimara_PBR_MinNdfRoughness);
		const float roughnessNDF = roughnessSQR * roughnessSQR;
		const float divSqrt = halfWayCosine * halfWayCosine * (roughnessNDF - 1.0) + 1.0;
		ndf = roughnessNDF / (divSqrt * divSqrt /* * PI */); // __TODO__: Do we need this PI here?
	}

	// Geometry function:
	float g;
	{
		const float roughnessPlus1 = fragment.roughness + 1.0;
		const float remappedRoughness = (roughnessPlus1 * roughnessPlus1) * 0.125;
		#define Jimara_PBR_DistributionGGX(cosine) cosine / (cosine * (1.0 - remappedRoughness) + remappedRoughness)
		g = Jimara_PBR_DistributionGGX(lightCosine) * Jimara_PBR_DistributionGGX(viewCosine);
		#undef Jimara_PBR_DistributionGGX
	}

	// Fresnel equasion:
	const vec3 f = FresnelSchlick(halfWayCosine, f0);

	// Split photon into specular and refracted parts and return the sum:
	const vec3 specularColor = (ndf * g * f) / max(4.0 * viewCosine * lightCosine, Jimara_PBR_MinNdfRoughness);
	const vec3 refractedColor = (1.0 - fragment.metalness) * (vec3(1.0) - f) * fragment.albedo /* / PI */;
	unclampedColor = (refractedColor + specularColor);
}

/// <summary>
/// Calculates bidirectional reflective distribution function of a single photon cast on a PBR fragment
/// </summary>
/// <param name="fragment"> PBR Fragment descriptor </param>
/// <param name="photon"> Incoming photon </param>
/// <param name="viewPosition"> Viewport/Camera position </param>
/// <returns> BRDF Evaluation </returns>
vec3 Jimara_PBR_BRDF(in const Jimara_PBR_Fragment fragment, in const Photon photon, in const vec3 viewPosition) {
	vec3 unclampedColor;
	float viewCosine;
	Jimara_PBR_Eval(fragment, photon.origin, photon.type, viewPosition, unclampedColor, viewCosine);
	return min(unclampedColor, 1.0) * viewCosine * photon.color;
}

#ifdef JM_ShaderStage
/// <summary>
/// Calculates bidirectional reflective distribution function of a single photon cast on a PBR fragment
/// </summary>
/// <param name="fragment"> PBR Fragment descriptor </param>
/// <param name="photon"> JM_BrdfQuery </param>
/// <returns> BRDF Evaluation </returns>
vec3 Jimara_PBR_BRDF(in const Jimara_PBR_Fragment fragment, in const JM_BrdfQuery query) {
	return Jimara_PBR_BRDF(fragment, Photon(fragment.position + query.lightDirection, query.color, query.photonType), fragment.position + query.viewDelta);
}

/// <summary>
/// Makes a bounce-light request
/// </summary>
/// <param name="fragment"> PBR Fragment descriptor </param>
/// <param name="viewDelta"> Fragment-to-view direction </param>
/// <param name="requestedSample"> Requested sample data </param>
/// <returns> True, if sample was requested </returns>
bool Jimara_PBR_RequestBounceSample(in const Jimara_PBR_Fragment fragment, in const vec3 viewDelta, out JM_BounceSample requestedSample) {
#ifndef Jimara_PBR_ENFORCE_DETERMINISTIC_SAMPLING
	// Sampling based on VNDF from https://jcgt.org/published/0007/04/01/ more or less directly with use-case-specific adjustments.

	// __TODO__: Use lighting-model-defined RNG...
	Jimara_RNG_t rng;
	JIMARA_RNG_seed(rng, 
		floatBitsToUint(fragment.position.x) + floatBitsToUint(viewDelta.x), 
		floatBitsToUint(fragment.position.y) + floatBitsToUint(viewDelta.y), 
		floatBitsToUint(fragment.position.z) + floatBitsToUint(viewDelta.z), 
		floatBitsToUint(viewDelta.x), 
		floatBitsToUint(viewDelta.y));
	#define JM_LM_SampleFloat() Jimara_RNG_float(rng)

	float roughness = max(fragment.roughness * fragment.roughness, Jimara_PBR_MinNdfRoughness);

	// First, we need to have view-delta-direction defined in fragment-space:
	vec2 vE;
	vec3 fragX;
	{
		vE.y = dot(fragment.normal, viewDelta);
		if (vE.y <= 00000001)
			return false; // We do not evaluate samples from beneath the surface.
		fragX = viewDelta - vE.y * fragment.normal;
		vE.x = length(fragX);
		if (vE.x > 0.0) 
			fragX /= vE.x;
		vE = normalize(vE);
	}

	vec3 normal;
	float pdf;
	if (roughness <= Jimara_PBR_MinNdfRoughness) {
		normal = fragment.normal;
		pdf = 1.0;
	}
	else 
	{
		// Normal:
		vec3 nE;
		{
			// Transforming the view direction to the hemisphere configuration:
			const vec3 vH = normalize(vec3(roughness * vE.x, vE.y, 0.0));

			// Orthonormal basis:
			const vec3 T1 = vec3(0.0, 0.0, sign(vH.x)); // We have defined our fragment-basis X aligned with viewDelta, so we have no need for additional calculations.
			const vec3 T2 = cross(vH, T1);

			// Parameterization of the projected area:
			const float r = sqrt(JM_LM_SampleFloat());
			const float phi = 2.0 * PI * JM_LM_SampleFloat();
			const float t1 = r * cos(phi);
			float t2 = r * sin(phi);
			const float s = 0.5 * (1.0 + vH.y);
			t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

			// Reprojection onto hemisphere:
			const vec3 nH = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * vH;

			// Sampled normal:
			nE = normalize(vec3(roughness * nH.x, max(0.0, nH.y), roughness * nH.z));
			normal = fragX * nE.x + fragment.normal * nE.y + cross(fragX, fragment.normal) * nE.z;
		}

		// PDF:
		{
			const float roughnessSQR = roughness * roughness;
			const float G1vE = 2.0 / (1.0 + sqrt(1.0 + roughnessSQR * (vE.x * vE.x) / (vE.y * vE.y)));
			const float halfWayCosine = max(dot(fragment.normal, normal), 0.0);
			const float denom = (halfWayCosine * halfWayCosine * (roughnessSQR - 1.0) + 1.0);
			float DnE = roughnessSQR / (PI * denom * denom);
			pdf = G1vE * max(0, dot(vE, nE.xy)) * DnE / vE.y;
			if (pdf < 0.00000001 || isnan(pdf))
				return false;
		}
	}

	// Fragment-to-world space normal and requested sample:
	{
		requestedSample.direction = normalize(reflect(-viewDelta, normal));
		vec3 brdfOverPDF;
		{
			vec3 color;
			float viewCosine;
			Jimara_PBR_Eval(fragment, 
				fragment.position + requestedSample.direction, Photon_Type_Default, fragment.position + viewDelta,
				color, viewCosine);
			if (roughness <= Jimara_PBR_MinNdfRoughness)
				color = min(color, 1.0);
			brdfOverPDF = min(color * (1.0 / pdf), 1.0) * viewCosine;
		}
		if (isnan(brdfOverPDF.x) || isnan(brdfOverPDF.y) || isnan(brdfOverPDF.z) ||
			isinf(brdfOverPDF.x) || isinf(brdfOverPDF.y) || isinf(brdfOverPDF.z))
			return false;
		requestedSample.colorTransform = mat3(
			vec3(brdfOverPDF.x, 0.0, 0.0),
			vec3(0.0, brdfOverPDF.y, 0.0),
			vec3(0.0, 0.0, brdfOverPDF.z));
		return true;
	}

#else
	// Hard-code mirror reflection for mirror-like surfaces: (__TODO__: Replace this with proper imporatnce sampling!).
	if (fragment.roughness < 0.1) {
		requestedSample.direction = normalize(reflect(-viewDelta, normalize(fragment.normal)));
		const vec3 eval = Jimara_PBR_BRDF(fragment, 
			Photon(fragment.position + requestedSample.direction, vec3(1.0, 1.0, 1.0), Photon_Type_Default), 
			fragment.position + viewDelta);
		requestedSample.colorTransform = mat3(
			vec3(eval.x, 0.0, 0.0),
			vec3(0.0, eval.y, 0.0),
			vec3(0.0, 0.0, eval.z));
		return true;
	}
	return false; // No bounce light [yet]
#endif
#undef JM_PBR_SAMPLE_VNDF
}
#endif


#endif
