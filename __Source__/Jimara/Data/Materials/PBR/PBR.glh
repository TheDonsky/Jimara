
#ifndef JIMARA_PBR_HEADER
#define JIMARA_PBR_HEADER
#include "../../../Math/Math.glh"
#include "../../../Environment/Rendering/Algorithms/Random/Jimara_RNG.glh"
/* PBR implementation "heavily inspired" by tutorial from https://learnopengl.com/PBR/Theory */


/// <summary>
/// PBR Fragment descriptor
/// </summary>
struct Jimara_PBR_Fragment {
	/// <summary> World-space position of the fragment </summary>
	vec3 position;
	
	/// <summary> World-space normal of the fragment (has to be normalized) </summary>
	vec3 normal;
	
	/// <summary> Albedo/Base color </summary>
	vec3 albedo;
	
	/// <summary> 'Metalness' value ([0 - 1] range) </summary>
	float metalness;
	
	/// <summary> Surface roughness ([0 - 1] range) </summary>
	float roughness;
};

/// <summary> sizeof(Jimara_PBR_Fragment) + padding </summary>
#define Jimara_PBR_Fragment_Size 64


/// <summary>
/// Calculates bidirectional reflective distribution function of a single photon cast on a PBR fragment
/// </summary>
/// <param name="fragment"> PBR Fragment descriptor </param>
/// <param name="photon"> Incoming photon </param>
/// <param name="viewPosition"> Viewport/Camera position </param>
/// <returns> BRDF Evaluation </returns>
vec3 Jimara_PBR_BRDF(in const Jimara_PBR_Fragment fragment, in const Photon photon, in const vec3 viewPosition) {
	// Calculate light & camera directions, alongside their mid-dir
	const vec3 lightDirection = normalize(photon.origin - fragment.position);
	const vec3 viewDirection = normalize(viewPosition - fragment.position);
	const vec3 halfWayDir = normalize(lightDirection + viewDirection);

	// Clamped cosines:
	const float lightCosine = max(dot(fragment.normal, lightDirection), 0.0);
	const float viewCosine = max(dot(fragment.normal, viewDirection), 0.0);
	const float halfWayCosine = max(dot(fragment.normal, halfWayDir), 0.0);
	
	// Common variables:
	const vec3 f0 = mix(vec3(0.04), fragment.albedo, fragment.metalness);
	#define Jimara_PBR_FresnelSchlick_ROUGHNESS (f0 + (max(vec3(1.0 - fragment.roughness), f0) - f0) * pow(1.0 - viewCosine, 5.0))

	// Special cases for the IBL.... (Let us trust compiler optimizations to simplify the code for special cases)
	if ((photon.type & Photon_Type_DiffuseIrradiance) == Photon_Type_DiffuseIrradiance) {
		return min(1.0 - Jimara_PBR_FresnelSchlick_ROUGHNESS, 1.0) * photon.color * fragment.albedo;
	}
	else if ((photon.type & Photon_Type_SpecularIrradiance) == Photon_Type_SpecularIrradiance) {
		const vec2 envBRDF = texture(jimara_BindlessTextures[nonuniformEXT(Jimara_BRDF_IntegrationMapId)],
			vec2(viewCosine, fragment.roughness)).rg;
		return photon.color * min(Jimara_PBR_FresnelSchlick_ROUGHNESS * envBRDF.x + envBRDF.y, 1.0);
	}
	#undef Jimara_PBR_FresnelSchlick_ROUGHNESS

	// Normal distribution function:
	float ndf;
	{
		const float roughnessSQR = max(fragment.roughness * fragment.roughness, 0.00001);
		const float roughnessNDF = roughnessSQR * roughnessSQR;
		const float divSqrt = halfWayCosine * halfWayCosine * (roughnessNDF - 1.0) + 1.0;
		ndf = roughnessNDF / (divSqrt * divSqrt /* * PI*/);
	}

	// Geometry function:
	float g;
	{
		const float roughnessPlus1 = fragment.roughness + 1.0;
		const float remappedRoughness = (roughnessPlus1 * roughnessPlus1) * 0.125;
		#define Jimara_PBR_DistributionGGX(cosine) cosine / (cosine * (1.0 - remappedRoughness) + remappedRoughness)
		g = Jimara_PBR_DistributionGGX(lightCosine) * Jimara_PBR_DistributionGGX(viewCosine);
		#undef Jimara_PBR_DistributionGGX
	}

	// Fresnel equasion:
	const vec3 f = FresnelSchlick(halfWayCosine, f0);

	// Split photon into specular and refracted parts:
	const vec3 specularColor = (ndf * g * f) / max(4.0 * viewCosine * lightCosine, 0.0000001);
	const vec3 refractedColor =  (1.0 - fragment.metalness) * (vec3(1.0) - f) * fragment.albedo /* / PI */;
	
	// Calculate resulting color:
	return min(refractedColor + specularColor, 1.0) * lightCosine * photon.color;
}

#ifdef JM_ShaderStage
/// <summary>
/// Calculates bidirectional reflective distribution function of a single photon cast on a PBR fragment
/// </summary>
/// <param name="fragment"> PBR Fragment descriptor </param>
/// <param name="photon"> JM_BrdfQuery </param>
/// <returns> BRDF Evaluation </returns>
vec3 Jimara_PBR_BRDF(in const Jimara_PBR_Fragment fragment, in const JM_BrdfQuery query) {
	return Jimara_PBR_BRDF(fragment, Photon(fragment.position + query.lightDirection, query.color, query.photonType), fragment.position + query.viewDelta);
}

/// <summary>
/// Makes a bounce-light request
/// </summary>
/// <param name="fragment"> PBR Fragment descriptor </param>
/// <param name="viewDelta"> Fragment-to-view direction </param>
/// <param name="requestedSample"> Requested sample data </param>
/// <returns> True, if sample was requested </returns>
bool Jimara_PBR_RequestBounceSample(in const Jimara_PBR_Fragment fragment, in const vec3 viewDelta, out JM_BounceSample requestedSample) {
#define JM_PBR_SAMPLE_VNDF 1

#if JM_PBR_SAMPLE_VNDF
	// Sampling based on VNDF from https://jcgt.org/published/0007/04/01/ more or less directly with use-case-specific adjustments.

	// __TODO__: Use lighting-model-defined RNG...
	Jimara_RNG_t rng;
	JIMARA_RNG_seed(rng, 
		floatBitsToUint(fragment.position.x) + floatBitsToUint(viewDelta.x), 
		floatBitsToUint(fragment.position.y) + floatBitsToUint(viewDelta.y), 
		floatBitsToUint(fragment.position.z) + floatBitsToUint(viewDelta.z), 
		floatBitsToUint(viewDelta.x), 
		floatBitsToUint(viewDelta.y));
	#define JM_LM_SampleFloat() Jimara_RNG_float(rng)

	float roughness = fragment.roughness;
	//roughness *= roughness;

	// First, we need to have view-delta-direction defined in fragment-space:
	vec2 vE;
	vec3 fragX;
	{
		vE.y = dot(fragment.normal, viewDelta);
		if (vE.y <= 00000001)
			return false; // We do not evaluate samples from beneath the surface.
		fragX = viewDelta - vE.y * fragment.normal;
		vE.x = length(fragX);
		if (vE.x > 0.0) 
			fragX /= vE.x;
		vE = normalize(vE);
	}

	vec3 nE;
	if (roughness <= 0.0000001)
		nE = vec3(0.0, 1.0, 0.0);
	else 
	{
		// Transforming the view direction to the hemisphere configuration:
		const vec3 vH = normalize(vec3(roughness * vE.x, vE.y, 0.0));

		// Orthonormal basis:
		const vec3 T1 = vec3(0.0, 0.0, sign(vH.x)); // We have defined our fragment-basis X aligned with viewDelta, so we have no need for additional calculations.
		const vec3 T2 = cross(vH, T1);

		// Parameterization of the projected area:
		const float r = sqrt(JM_LM_SampleFloat());
		const float phi = 2.0 * PI * JM_LM_SampleFloat();
		const float t1 = r * cos(phi);
		float t2 = r * sin(phi);
		const float s = 0.5 * (1.0 + vH.y);
		t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

		// Reprojection onto hemisphere:
		const vec3 nH = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * vH;

		// Sampled normal in fragment-space:
		nE = normalize(vec3(roughness * nH.x, max(0.0, nH.y), roughness * nH.z));
	}

	// PDF for throughput:
	float pdf;
	if (roughness <= 0.0000001)
		pdf = 1.0;
	else 
	{
		const float alphaSqr = max(roughness * roughness, 0.0000001);
		const float G1vE = 2.0 / (1.0 + sqrt(1.0 + alphaSqr * (vE.x * vE.x) / (vE.y * vE.y)));
		const float denom = 
			// nE is an unit vector, so the expression below is the same as (nE.x * nE.x + nE.z * nE.z + (nE.y * nE.y) * alphaSqr).
			(nE.y * nE.y * (alphaSqr - 1.0) + 1.0);
		float DnE = alphaSqr / (PI * denom * denom);
		pdf = G1vE * max(0, dot(vE, nE.xy)) * DnE / vE.y;
		if (pdf < 0.00000001)
			return false;
	}
	pdf = 1.0;

	// Fragment-to-world space normal and requested sample:
	{
		vec3 normal = fragX * nE.x + fragment.normal * nE.y + cross(fragX, fragment.normal) * nE.z;
		requestedSample.direction = normalize(reflect(-viewDelta, normal)); 
		const vec3 brdfOverPDF = Jimara_PBR_BRDF(fragment, 
			Photon(fragment.position + requestedSample.direction, vec3(1.0, 1.0, 1.0), Photon_Type_Default), 
			fragment.position + viewDelta)
			* (1.0 / pdf);
		requestedSample.colorTransform = mat3(
			vec3(brdfOverPDF.x, 0.0, 0.0),
			vec3(0.0, brdfOverPDF.y, 0.0),
			vec3(0.0, 0.0, brdfOverPDF.z));
		return true;
	}

#else
	// Hard-code mirror reflection for mirror-like surfaces: (__TODO__: Replace this with proper imporatnce sampling!).
	if (fragment.roughness < 0.1) {
		requestedSample.direction = normalize(reflect(-viewDelta, normalize(fragment.normal)));
		const vec3 eval = Jimara_PBR_BRDF(fragment, 
			Photon(fragment.position + requestedSample.direction, vec3(1.0, 1.0, 1.0), Photon_Type_Default), 
			fragment.position + viewDelta);
		requestedSample.colorTransform = mat3(
			vec3(eval.x, 0.0, 0.0),
			vec3(0.0, eval.y, 0.0),
			vec3(0.0, 0.0, eval.z));
		return true;
	}
	return false; // No bounce light [yet]
#endif
#undef JM_PBR_SAMPLE_VNDF
}
#endif


#endif
