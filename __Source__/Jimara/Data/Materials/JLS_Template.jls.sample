
// Each lit shader defines it's public name and path for the editor as follows:
#pragma JM_MaterialPath(name = "Example Mat", path = "Jimara/Example Mat", hint = "Material description");
// By default, name will be the same as the filename, path will be the relative path from the project root and hint will just refer to those two


// Each lit shader defines it's blending mode as follows:
#pragma JM_BlendMode JM_Blend_Opaque
// Avaliable choices are as follows:
// JM_Blend_Opaque   - Opaque;
// JM_Blend_Alpha    - Alpha-blended;
// JM_Blend_Additive - Additively-blended;
// (Cutouts are controlled by JM_CanDiscard material flag)
// Value of this pragma, as well as values of the blend-modes will be appended as macro definitions during compilations


// Lit shaders define which optional vertex inputs to use, 
// as well as some other optimization and/or features to use through JM_MaterialFlags:
#pragma JM_MaterialFlags (JM_CanDiscard | JM_UseVertexColor)
// Avaliable flags are as follows:
// JM_CanDiscard - Allows fragment discard when JM_Init fails;
// JM_UseObjectId - Exposes JM_ObjectIndex through JM_VertexInput
// JM_UsePerVertexTilingAndOffset - Exposes JM_ObjectTilingAndOffset through JM_VertexInput
// JM_UseVertexColor - Exposes JM_VertexColor through JM_VertexInput
// JM_UseTangents - Exposes derived tangent and bitangent vectors through JM_VertexInput
// Value of this pragma, as well as values of the blend-modes will be appended as macro definitions during compilations


// Each lit shader defines it's material properties like this:
#pragma JM_MaterialProperty float propertyName0;
#pragma JM_MaterialProperty() vec4 propertyName1;
#pragma JM_MaterialProperty(default = { 0, 1, 0 }) vec3 propertyName2;
#pragma JM_MaterialProperty(hint = "This will show-up as a hint when hovered in editor") vec3 propertyName3;
#pragma JM_MaterialProperty(alias = "Editor will show this instead of 'propertyName4'") mat4 propertyName4;
#pragma JM_MaterialProperty(alias = "Alias", hint = "Hint", default = 9) int propertyName5;
#pragma JM_MaterialProperty() sampler2D propertyName6;
#pragma JM_MaterialProperty(default = { 0, 1, 0, 1 }) sampler2D propertyName7;
// etc...
#pragma JM_MaterialProperty float propertyNameN;
// ValueType can be any built-in numeric types or a sampler;
// Defaults are 0-values in case of numbers and 'white-texture' in case of samplers and images;
// Defaults do not need typenames and including those will cause errors! 
// Contents of the default values will not be validated untill the generated source compilation, so if there are issues, expect the compiler to fail with generated source.
// 'JM' and 'jm' prefixes are reserved for engine-defined variable names and should not be present in the definitions, unless specified.
// Current preprocessor DOES NOT support custom structure parsing and, because of that, they are not allowed for now; Expect that to change eventually.

// Shader compiler Will automatically create a corresponding structure for the lit shaders:
struct JM_MaterialProperties {
	float propertyName0;
	vec4 propertyName1;
	vec3 propertyName2;
	vec3 propertyName3;
	mat4 propertyName4;
	int propertyName5;
	sampler2D propertyName6;
	sampler2D propertyName7;
	// etc...
	float propertyNameN;
};


// Each lit-shader defines it's fragment shader inputs as follows:
#pragma JM_FragmentField float fieldName0;
#pragma JM_FragmentField vec3 fieldName1;
#pragma JM_FragmentField int fieldName2;
// etc...
#pragma JM_FragmentField TypeNameN fieldNameN;
// JM_Position is a reserved mandatory fragment-field and does not need a definition; 
// Having said that, the lit-shader is responsible for filling it.
// Integers are allowed, but keep in mind, that they will be subject to the limitations of vertex shader out-variables;
// Any type is allowed, as long as it has a well-defined mix(Type, Type, float) implementation 
// that EXACTLY MATCHES the rasterizer's fragment-in variable blending behaviour
// Keep in mind, that preprocessor will take no responsibility for making sure the typenames are valid and variable names can be used; Expect compiler error if you mess-up.

// Shader compiler Will automatically create a corresponding structure and helpers for the lit shader fragments:
struct JM_FragmentData {
	vec3 JM_Position;
	float fieldName0;
	vec3 fieldName1;
	int fieldName2;
	// etc...
	TypeNameN fieldNameN;
}
JM_FragmentData mix(JM_FragmentData a, JM_FragmentData b, float t);
// As side-note, currently there is no support for tesselation stages and also no support for in-shader-vector-displacement for ray-traced lighting models
// More will be added to the API if and when they get enabled.



// Fixed vertex input for all types (provided by lit-shader compiler):
struct JM_VertexInput {
	mat4 transform;			// JM_ObjectTransform;

	vec3 position;			// JM_VertexPosition
	vec3 normal;			// JM_VertexNormal
	vec2 uv;				// JM_VertexUV

#if (JM_MaterialFlags & JM_UseObjectId) != 0
	uint objectId;			// JM_ObjectIndex (optional; enabled via JM_MaterialFlags JM_UseObjectId flag)
#endif

#if (JM_MaterialFlags & JM_UsePerVertexTilingAndOffset) != 0
	vec4 tilingAndOffset;	// JM_ObjectTilingAndOffset (optional; enabled via JM_MaterialFlags JM_UsePerVertexTilingAndOffset flag)
#endif

#if (JM_MaterialFlags & JM_UseVertexColor) != 0
	vec4 vertexColor;		// JM_VertexColor (optional; enabled via JM_MaterialFlags JM_UseVertexColor flag)
#endif

#if (JM_MaterialFlags & JM_UseTangents) != 0
	vec3 tangent;			// Tangent vector, derived from JM_VertexPosition, JM_VertexNormal and JM_VertexUV members of the geometry
	vec3 bitangent;			// Bitangent vector, derived from JM_VertexPosition, JM_VertexNormal and JM_VertexUV members of the geometry
#endif
};

// Fixed light info for all types (provided by lit-shader compiler):
struct JM_BrdfQuery {
	vec3 lightDirection;	// Fragment-to-light direction
	vec3 viewDelta;			// Fragment-to-view/observer direction multiplied by distance
	vec3 color;				// Photon color/energy per-channel
	uint photonType;		// Photon sample type (view Jimara/Environment/Rendering/SceneObjects/Lights/Photon.glh for further details)
};

// Fixed sample request structure for all types (provided by lit-shader compiler):
struct JM_BounceSample {
	vec3 direction;			// Fragment-to-reflection-source direction
	mat3 colorTransform;	// colorTransform * JM_BrdfQuery.color will be assumed to be reflected color, without re-invoking JM_EvaluateBrdf when calculating reflections
};


// Has to be defined within material source:
struct JM_ShadingState {
	// Required:
	vec3 normal; 			// World-space normal
	float roughness;		// [0.0 - 1.0]

	// Any other shader-defined data goes here...
};
// Current preprocessor is unable to evaluate structure sizes and some lighting models might need to know about it;
// This is a temporary band-aid to allow that. Sometime later in the future, this will no longer be required.
#pragma JM_ShadingStateSize 64; // This values is just a placeholder; JM_ShadingState size should be measured with regular GLSL rules



// Has to be defined within material source:
JM_FragmentData JM_EvaluateVertex(in const JM_VertexInput vertexInput, in const JM_MaterialProperties materialProperties) {
	// User-Defined implementation...
}

// Has to be defined within material source:
bool JM_Init(in JM_FragmentData fragmentInput, in const JM_MaterialProperties materialProperties, out JM_ShadingState state) {
	// User-Defined implementation...
	return trueIfFragmentShouldNotBeDiscarded; // (false value may be ignored if JM_MaterialFlags does not contain JM_CanDiscard flag)
}

#if JM_BlendMode != JM_Blend_Opaque
// Has to be defined within material source:
float JM_Opacity(inout JM_ShadingState state) {
	// User-Defined implementation...
}
#endif

// Has to be defined within material source:
vec3 JM_Emission(inout JM_ShadingState state, in const vec3 viewDelta) {
	// Should return emission color.
}

// Has to be defined within material source:
vec3 JM_EvaluateBrdf(inout JM_ShadingState state, in const JM_BrdfQuery query) {
	// Should evaluate BRDF and return the color of the photon reflected in view/observer direction
}

// Has to be defined within material source:
bool JM_RequestBounceSample(inout JM_ShadingState state, in const vec3 viewDelta, out JM_BounceSample requestedSample) {
	// Should generate a bounce-sample request, store it's direction and color-response in requestedSample and return true, 
	// or return false if the surface does not need any bounce light.
}





// Lighting models will have access to the following structure and definitions, that will mirror the settings buffer from the host:
// (Lit-shaders can ignore these definitions)

// This will serve as the generated material's property buffer that can be bound directly or used with bindless index:
struct JM_MaterialProperties_Buffer {
	float propertyName0;
	uint jm_padding0, jm_padding1, jm_padding2; // Pad-variables will be added to make the alignment obvious. User should not care about those...
	vec4 propertyName1;
	// ...
	uint propertyName6; // Bindless-index instead of sampler2D
	// etc...
	float propertyNameN;
};

// GLSL does not have sizeof()... This will be calculated by compiler script:
#define JM_Materialproperties_BufferSize sizeof(JM_MaterialProperties_Buffer)

// Lighting model will be able to quickly get JM_MaterialProperties from JM_MaterialProperties_Buffer and bindless sampler array using this macro:
#define JM_MaterialPropertiesFromBuffer(/* JM_MaterialProperties_Buffer */ jm_buff, /* jimara_BindlessTextures */ jm_samplers, /* nonuniformEXT or uint */ jm_qualifier) \
	JM_MaterialProperties( \
		jm_buff.propertyName0, \
		/* ... */ \
		jm_samplers[jm_qualifier(jm_buff.propertyName6)], \
		/* etc... */ \
		jm_buff.propertyNameN)

// For direct-bindings, lighting model can use this macro:
// . Non-texture settings will be bound to jm_MaterialSettingsBuffer with JM_MaterialProperties_Buffer data;
// . Textures will be bound by names jm_MaterialSamplerBinding0, jm_MaterialSamplerBinding1 and so on;
// . JM_MaterialPropertiesFromBindings() function will be generated for quick access to JM_MaterialProperties
#define JM_DefineDirectMaterialBindings(/* int */ jm_bindingSet, /* int */ jm_firstBinding) \
	layout(set = jm_bindingSet, binding = jm_firstBinding) uniform JM_MaterialSettingsBuffer { JM_MaterialProperties_Buffer data; } jm_MaterialSettingsBuffer; \
	layout(set = jm_bindingSet, binding = (jm_firstBinding + 1)) uniform sampler2D jm_MaterialSamplerBinding0; \
	/* Any other sampler2D properties... */ \
	JM_MaterialProperties JM_MaterialPropertiesFromBindings() { \
		return JM_MaterialProperties( \
			jm_MaterialSettingsBuffer.data.propertyName0, \
			/* ... */ \
			/* propertyName6 */ jm_MaterialSamplerBinding0, \
			/* etc... */ \
			jm_MaterialSettingsBuffer.data.propertyNameN); \
	}

// In case binding set defined by JM_DefineDirectMaterialBindings needs to contain more entries, this macro will be exposed to the lighting models
#define JM_DirectMaterialBindingCount (TotalTextureBindingCount + 1)
