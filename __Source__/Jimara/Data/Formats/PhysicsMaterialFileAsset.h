#pragma once
#include "../../Physics/PhysicsInstance.h"
#include "../../OS/IO/Path.h"
#include "../AssetDatabase/AssetDatabase.h"
#include "../Serialization/Helpers/SerializeToJson.h"


namespace Jimara {
	class PhysicsMaterialFileAsset;

	// Registration
	JIMARA_REGISTER_TYPE(Jimara::PhysicsMaterialFileAsset);

	// TypeId detail callbacks
	template<> JIMARA_API void TypeIdDetails::OnRegisterType<PhysicsMaterialFileAsset>();
	template<> JIMARA_API void TypeIdDetails::OnUnregisterType<PhysicsMaterialFileAsset>();
	template<> struct JIMARA_API TypeIdDetails::TypeDetails<PhysicsMaterialFileAsset> {
	private:
		static void OnRegisterType();
		static void OnUnregisterType();

		friend void TypeIdDetails::OnRegisterType<PhysicsMaterialFileAsset>();
		friend void TypeIdDetails::OnUnregisterType<PhysicsMaterialFileAsset>();
	};
	template<> inline void TypeIdDetails::GetParentTypesOf<PhysicsMaterialFileAsset>(const Callback<TypeId>& report) {
		report(TypeId::Of<ModifiableAsset::Of<Physics::PhysicsMaterial>>());
	}
	template<> inline void TypeIdDetails::GetTypeAttributesOf<PhysicsMaterialFileAsset>(const Callback<const Object*>&) {}

#pragma warning(disable: 4250)
	/// <summary>
	/// File system asset for physics materials
	/// </summary>
	class JIMARA_API PhysicsMaterialFileAsset : public virtual ModifiableAsset::Of<Physics::PhysicsMaterial> {
	protected:
		/// <summary>
		/// Loads pysics material
		/// </summary>
		/// <returns> Heirarchy spowner </returns>
		virtual Reference<Physics::PhysicsMaterial> LoadItem() override;

		/// <summary>
		/// Stores physics material data to the file
		/// </summary>
		/// <param name="resource"> Resource, that has previously been loaded with LoadItem() call and now has been changed (alegedly) </param>
		virtual void Store(Physics::PhysicsMaterial* resource) override;

	public:
		/// <summary>
		/// Serializes physics material into json
		/// </summary>
		/// <param name="material"> Physics material to serialize </param>
		/// <param name="log"> Logger for error reporting </param>
		/// <param name="error"> If error occures, this flag will be set </param>
		/// <returns> Serialized data </returns>
		static nlohmann::json SerializeToJson(Physics::PhysicsMaterial* material, OS::Logger* log, bool& error);

		/// <summary>
		/// Extracts physics material data from a json
		/// </summary>
		/// <param name="material"> Physics material to store data into </param>
		/// <param name="database"> Database for external references </param>
		/// <param name="log"> Logger for error reporting </param>
		/// <param name="serializedData"> Serialized data [possibly generated by previous SerializeMaterial() call] </param>
		/// <returns> True, if no error occures </returns>
		static bool DeserializeFromJson(Physics::PhysicsMaterial* material, AssetDatabase* database, OS::Logger* log, const nlohmann::json& serializedData);

		/// <summary> Material file extension </summary>
		static const OS::Path& Extension();

	private:
		// Internal asset importer class
		class Importer;

		// Lock for importer reference
		SpinLock m_importerLock;

		// Importer reference (Alive only while the FileSystemDB is alive and file exists; beyond that, Load/Store operations will fail miserably)
		Importer* m_importer;

		// Constructor
		PhysicsMaterialFileAsset(const GUID& guid, Importer* importer);

		// Type id details need access to internals
		friend struct TypeIdDetails::TypeDetails<PhysicsMaterialFileAsset>;
	};
#pragma warning(default: 4250)
}
