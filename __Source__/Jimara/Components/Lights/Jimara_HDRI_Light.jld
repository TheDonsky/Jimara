
#include <Math/Math.glh>
#include <Environment/Rendering/Algorithms/Random/Jimara_RNG.glh>
#include <Environment/Rendering/SceneObjects/Lights/Photon.glh>
#pragma jimara_light_descriptor_size 32
struct Jimara_HDRI_Light_Data {
	vec3 color;
	uint textureID;
	float numMipLevels;
	float mipBias;
	uint sampleCount;
};

mat4 Jimara_ViewMatrix();

struct Jimara_HDRI_Light_SampleIterator {
	Jimara_RNG_t rng;
	vec3 hitPoint;
	vec3 normal;
	vec3 naturalReflectionDir;
	float roughness;
	vec3 baseColor;
	uint textureID;
	float numMipLevels;
	float mipBias;
	uint counter;
};

Jimara_HDRI_Light_SampleIterator Jimara_HDRI_Light_GetIterator(in HitPoint hitPoint, in Jimara_HDRI_Light_Data lightData) {
	const vec3 cameraPosition = inverse(Jimara_ViewMatrix())[3].rgb;
	const vec3 hitDelta = (hitPoint.position - cameraPosition);
	
	Jimara_HDRI_Light_SampleIterator it;
	JIMARA_RNG_seed(it.rng, 0);
	it.hitPoint = hitPoint.position;
	it.normal = normalize(hitPoint.normal);
	it.naturalReflectionDir = normalize(hitDelta - 2.0 * it.normal * dot(it.normal, hitDelta));
	it.roughness = hitPoint.roughness;
	it.baseColor = lightData.color;
	it.textureID = lightData.textureID;
	it.numMipLevels = lightData.numMipLevels;
	it.mipBias = lightData.mipBias;
	it.counter = lightData.sampleCount;
	it.baseColor /= it.counter;
	return it;
}

vec3 Jimara_HDRI_Light_SampleTexture(uint textureID, in const vec3 reflectionDir, float roughness, float numMipLevels, float mipBias) {
	// reflectionDir = vec3(cos(yaw) * cos(pitch), sin(pitch), sin(yaw) * cos(pitch)):
	const float pitch = asin(reflectionDir.y); // Range: [-PI/2; PI/2]
	const float yaw = acos(normalize(vec2(reflectionDir.x, reflectionDir.z)).x) * (reflectionDir.z >= 0.0 ? 1.0 : -1.0); // Range: [-PI, PI]
	
	// Color:
	const float mip = numMipLevels * roughness + mipBias;
	const vec2 uv = vec2((yaw + PI) * 0.5, 0.5 * PI - pitch) * (1.0 / PI);
	return textureLod(jimara_BindlessTextures[nonuniformEXT(textureID)], uv, mip).rgb;
}

bool Jimara_HDRI_Light_GetSample(inout Jimara_HDRI_Light_SampleIterator it, out Photon photon) {
	if (it.counter <= 0) 
		return false;
	it.counter--;
	
	vec3 reflectionDir = Jimara_RNG_PointOnSphere(it.rng);
	if (dot(it.normal, reflectionDir) < 0.0)
		reflectionDir *= -1.0;
	reflectionDir = mix(it.naturalReflectionDir, reflectionDir, it.roughness);

	// Direct reflection color:
	const vec3 color = Jimara_HDRI_Light_SampleTexture(
		it.textureID, reflectionDir, it.roughness, it.numMipLevels, it.mipBias);

	// Sample:
	photon.origin = (it.hitPoint + reflectionDir);
	photon.color = (it.baseColor * color);
	photon.type = Photon_Type_SpecularIrradiance;
	return true;
}

void Jimara_HDRI_Light_GetSampleIOR(in HitPoint hitPoint, in Jimara_HDRI_Light_Data lightData, out Photon photon) {
	const vec3 color = Jimara_HDRI_Light_SampleTexture(
		lightData.textureID, hitPoint.normal, 1.0, lightData.numMipLevels - 3.0, lightData.mipBias);
	photon.origin = (hitPoint.position + hitPoint.normal);
	photon.color = (lightData.color * color);
	photon.type = Photon_Type_DiffuseIrradiance;
}

#define Jimara_HDRI_Light_GetSamples(JHDRIL_hitPoint, JHDRIL_lightData, JHDRIL_recordSample) { \
	Jimara_HDRI_Light_SampleIterator JHDRIL_it = Jimara_HDRI_Light_GetIterator(JHDRIL_hitPoint, JHDRIL_lightData); \
	Photon JHDRIL_photon; \
	while (Jimara_HDRI_Light_GetSample(JHDRIL_it, JHDRIL_photon)) \
		JHDRIL_recordSample(JHDRIL_photon); \
	Jimara_HDRI_Light_GetSampleIOR(JHDRIL_hitPoint, JHDRIL_lightData, JHDRIL_photon); \
	JHDRIL_recordSample(JHDRIL_photon); \
}
