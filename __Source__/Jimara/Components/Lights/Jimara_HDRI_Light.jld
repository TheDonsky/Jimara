
#include <Math/Math.glh>
#pragma jimara_light_descriptor_size 16
struct Jimara_HDRI_Light_Data {
	vec3 color;
	uint textureID;
};

mat4 Jimara_ViewMatrix();

uint Jimara_HDRI_Light_GetSamples(in HitPoint hitPoint, in Jimara_HDRI_Light_Data lightData, out Photon samples[MAX_PER_LIGHT_SAMPLES]) {
	const vec3 cameraPosition = inverse(Jimara_ViewMatrix())[3].rgb;
	const vec3 hitDelta = (hitPoint.position - cameraPosition);
	const vec3 normal = normalize(hitPoint.normal);
	const vec3 reflectionDir = normalize(hitDelta - 2.0 * normal * dot(normal, hitDelta));
	
	// reflectionDir = vec3(cos(yaw) * cos(pitch), sin(pitch), sin(yaw) * cos(pitch));
	const float pitch = asin(reflectionDir.y); // Range: [-PI/2; PI/2]
	const float yaw = acos(normalize(vec2(reflectionDir.x, reflectionDir.z)).x) * (reflectionDir.z >= 0.0 ? 1.0 : -1.0); // Range: [-PI, PI]
	
	// Direct reflection color:
	const vec2 uv = vec2((yaw + PI) * 0.5, 0.5 * PI - pitch) * (1.0 / PI);
	const vec3 color = texture(jimara_BindlessTextures[nonuniformEXT(lightData.textureID)], uv).rgb * lightData.color;

	// Sample:
	Photon photon;
	photon.origin = (hitPoint.position + reflectionDir);
	photon.color = color;
	samples[0] = photon;
	return 1;
}
