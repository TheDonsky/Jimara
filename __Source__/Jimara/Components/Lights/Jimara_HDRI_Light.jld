
#include <Math/Math.glh>
#pragma jimara_light_descriptor_size 32
struct Jimara_HDRI_Light_Data {
	vec3 color;
	uint textureID;
	float numMipLevels;
	float mipBias;
};

mat4 Jimara_ViewMatrix();

bool Jimara_HDRI_Light_GetSample(in HitPoint hitPoint, in Jimara_HDRI_Light_Data lightData, out Photon photon) {
	const vec3 cameraPosition = inverse(Jimara_ViewMatrix())[3].rgb;
	const vec3 hitDelta = (hitPoint.position - cameraPosition);
	const vec3 normal = normalize(hitPoint.normal);
	const vec3 reflectionDir = normalize(hitDelta - 2.0 * normal * dot(normal, hitDelta));
	
	// reflectionDir = vec3(cos(yaw) * cos(pitch), sin(pitch), sin(yaw) * cos(pitch));
	const float pitch = asin(reflectionDir.y); // Range: [-PI/2; PI/2]
	const float absYaw = acos(normalize(vec2(reflectionDir.x, reflectionDir.z)).x); // Range: [0, PI]
	
	// Direct reflection color:
	vec3 color = lightData.color;
	const float mip = lightData.numMipLevels * hitPoint.roughness + lightData.mipBias;
	[[flatten]]
	if (reflectionDir.z >= 0.0) {
		const vec2 uv = vec2((absYaw + PI) * 0.5, 0.5 * PI - pitch) * (1.0 / PI);
		color *= textureLod(jimara_BindlessTextures[nonuniformEXT(lightData.textureID)], uv, mip).rgb;
	}
	else {
		const vec2 uv = vec2((PI - absYaw) * 0.5, 0.5 * PI - pitch) * (1.0 / PI);
		color *= textureLod(jimara_BindlessTextures[nonuniformEXT(lightData.textureID)], uv, mip).rgb;
	}

	// Sample:
	photon.origin = (hitPoint.position + reflectionDir);
	photon.color = color;
	return true;
}

#define Jimara_HDRI_Light_GetSamples(JHDRIL_hitPoint, JHDRIL_lightData, JHDRIL_recordSample) \
	{ Photon JHDRIL_photon; if (Jimara_HDRI_Light_GetSample(JHDRIL_hitPoint, JHDRIL_lightData, JHDRIL_photon)) JHDRIL_recordSample(JHDRIL_photon); }
