
#ifndef SCENE_LIGHT_GRID_HEADER_INCLUDED
#define SCENE_LIGHT_GRID_HEADER_INCLUDED

/// <summary> 
/// In order to use scene light grid, include this header in your shader
/// after defining SCENE_LIGHT_GRID_BINDING_SET and SCENE_LIGHT_GRID_BINDING_START_ID 
/// for binding set and binding slot start indices. SceneLightGrid will consume bindings 
/// from SCENE_LIGHT_GRID_BINDING_START_ID to generated SCENE_LIGHT_GRID_BINDING_END_ID
/// and fill them in with hard-coded binding names.
/// <para/> 
/// Keep in mind, that there are two types of voxels: Regular ones, for localized light sources,
/// accessed though SceneLightGrid_GetLocalLightIndexRange() call and one unified bucket for 
/// all 'global' lights that should be taken into consideration everywhere, 
/// accessed via SceneLightGrid_GetGlobalLightIndexRange() call.
/// <para/>
/// Use SceneLightGrid_GetLightCount() to get number of lights within a voxel and
/// SceneLightGrid_GetLightIndex() to translate voxel light index to global light index
/// (You can use SceneLightInfo/LightTypeIdBuffer or anything else following the order from ViewportLightSet)
/// <para/>
/// On the source code side, one needs to create/get instance of a SceneLightGrid collection,
/// attach it's bindings to the BindingSet instance and wait for the UpdateJob before it's safe to use in the command buffers.
/// </summary>


/// <summary> Per-voxel data of scene light grid </sumary>
struct SceneLightGrid_VoxelRange {
	uint start;
	uint count;
};

/// <summary> Number of max relevant buckets per point in space </summary>
#define SceneLightGrid_PerPointRangeCount 9

/// <summary> Short for SceneLightGrid_VoxelRange[SceneLightGrid_PerPointRangeCount] </summary>
#define SceneLightGrid_IlluminatingVoxels SceneLightGrid_VoxelRange[SceneLightGrid_PerPointRangeCount]

/// <summary>  </sumary>
#define SCENE_LIGHT_GRID_BINDING_END_ID (SCENE_LIGHT_GRID_BINDING_START_ID + 4)

/// <summary> Grid settings </sumary>
layout(set = SCENE_LIGHT_GRID_BINDING_SET, binding = SCENE_LIGHT_GRID_BINDING_START_ID) uniform SceneLightGrid_SettingsBuffer {
	vec3 gridOrigin;
	vec3 voxelSize;
	uvec3 voxelGroupCount;
	uvec3 voxelGroupSize;
	uint globalLightCount;
} SceneLightGrid_settingsBuffer;

/// <summary> Voxel group data </sumary>
layout(set = SCENE_LIGHT_GRID_BINDING_SET, binding = (SCENE_LIGHT_GRID_BINDING_START_ID + 1)) buffer readonly SceneLightGrid_VoxelGroupBuffer {
	uint voxels[];
} SceneLightGrid_voxelGroupBuffer;

/// <summary> Voxel data </sumary>
layout(set = SCENE_LIGHT_GRID_BINDING_SET, binding = (SCENE_LIGHT_GRID_BINDING_START_ID + 2)) buffer readonly SceneLightGrid_VoxelBuffer {
	SceneLightGrid_VoxelRange ranges[];
} SceneLightGrid_voxelBuffer;

/// <summary> Light index data, ranges point to </sumary>
layout(set = SCENE_LIGHT_GRID_BINDING_SET, binding = (SCENE_LIGHT_GRID_BINDING_START_ID + 3)) buffer readonly SceneLightGrid_LightIndexBuffer {
	uint indices[];
} SceneLightGrid_lightIndexBuffer;


/// <summary> Fills voxel content for world-space position </sumary>
/// <param name="position"> World-space position </param>
/// <param name="ranges"> Ranges to fill </param>
void SceneLightGrid_GetIlluminatingVoxels(in vec3 position, out SceneLightGrid_VoxelRange ranges[SceneLightGrid_PerPointRangeCount]) {
	{
		SceneLightGrid_VoxelRange emptyRange;
		emptyRange.start = 0;
		emptyRange.count = 0;
		#pragma unroll SceneLightGrid_PerPointRangeCount
		for (uint i = 0; i < SceneLightGrid_PerPointRangeCount; i++)
			ranges[i] = emptyRange;
	}

	ranges[0].count = SceneLightGrid_settingsBuffer.globalLightCount;

	const vec3 voxelSpacePos = (position - SceneLightGrid_settingsBuffer.gridOrigin) / SceneLightGrid_settingsBuffer.voxelSize;
	if (voxelSpacePos.x < 0 || voxelSpacePos.y < 0 || voxelSpacePos.z < 0) return;

	const uvec3 voxelIndex = uvec3(uint(voxelSpacePos.x), uint(voxelSpacePos.y), uint(voxelSpacePos.z));
	const uvec3 voxelCount = SceneLightGrid_settingsBuffer.voxelGroupCount * SceneLightGrid_settingsBuffer.voxelGroupSize;
	if (voxelIndex.x >= voxelCount.x || voxelIndex.y >= voxelCount.y || voxelIndex.z >= voxelCount.z) return;
	
	const uvec3 voxelGroupIndex = voxelIndex / SceneLightGrid_settingsBuffer.voxelGroupSize;
	const uint voxelGroupOrigin = SceneLightGrid_voxelGroupBuffer.voxels[
		SceneLightGrid_settingsBuffer.voxelGroupCount.x * 
		(SceneLightGrid_settingsBuffer.voxelGroupCount.y * voxelGroupIndex.z + voxelGroupIndex.y) + voxelGroupIndex.x];
	if (voxelGroupOrigin >= ~uint(0)) return;

	const uvec3 groupVoxelIndex = voxelIndex - (voxelGroupIndex * SceneLightGrid_settingsBuffer.voxelGroupSize);
	const SceneLightGrid_VoxelRange voxelRange = SceneLightGrid_voxelBuffer.ranges[voxelGroupOrigin + 
		SceneLightGrid_settingsBuffer.voxelGroupSize.x * 
		(SceneLightGrid_settingsBuffer.voxelGroupSize.y * groupVoxelIndex.z + groupVoxelIndex.y) + groupVoxelIndex.x];
	
	const vec3 voxelQuarterPos = voxelSpacePos - vec3(float(voxelIndex.x), float(voxelIndex.y), float(voxelIndex.z));
	uint resultIndex = 1;
	if (voxelQuarterPos.x < 0.5)
		resultIndex += 1;
	if (voxelQuarterPos.y < 0.5)
		resultIndex += 2;
	if (voxelQuarterPos.z < 0.5)
		resultIndex += 4;
	ranges[resultIndex] = voxelRange;
}

/// <summary> Number of lights within a voxel </sumary>
/// <param name="range"> Voxel info </param>
/// <returns> Number of lights within a voxel </returns>
uint SceneLightGrid_GetLightCount(in SceneLightGrid_VoxelRange range) {
	return range.count;
}

/// <summary> Translates voxel light index into the global index </sumary>
/// <param name="range"> Voxel info </param>
/// <param name="index"> Light index within the voxel </param>
/// <returns> Global light index </returns>
uint SceneLightGrid_GetLightIndex(in SceneLightGrid_VoxelRange range, uint index) {
	return SceneLightGrid_lightIndexBuffer.indices[range.start + index];
}

#endif

