#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : require
#include "../../Algorithms/SegmentTree/SegmentTree.glh"

layout (set = 0, binding = 0) buffer SegmentTreeBuffer {
	int[] values;
} segmentTreeBuffer;

int EvaluateSegmentTreeRange(uint start, uint end, uint segmentTreeSize) {
	int value = 0;
	#define Jimara_SegmentTree_IncorporateFn(index) value += segmentTreeBuffer.values[index];
	Jimara_SegmentTree_IncorporateRange(start, end, segmentTreeSize, Jimara_SegmentTree_IncorporateFn)
	#undef Jimara_SegmentTree_IncorporateFn
	return value;
}

struct SimulationTaskSettings {
	uint64_t liveInstanceRangeBufferOrSegmentTreeSize;	// Bytes [0 - 8)
	uint firstInstanceIndexOffset;						// Bytes [8 - 12)
	uint firstInstanceIndexStride;						// Bytes [12 - 16)
	uint instanceCountOffset;							// Bytes [16 - 20)
	uint instanceCountStride;							// Bytes [20 - 24)

	uint liveRangeStart;								// Bytes [24 - 28)
	uint taskThreadCount;								// Bytes [28 - 32)

	uint64_t jm_objectTransformBuffer;					// Bytes [32 - 40)
	uint jm_objectTransformBufferStride;				// Bytes [40 - 44)

	uint liveInstanceRangeCount;						// Bytes [44 - 48)
};

layout(buffer_reference) buffer readonly LiveInstanceRangeBuffers { uint value; };

void ExecuteSimulationTask(in SimulationTaskSettings settings, uint instanceId) {
	bool instanceLive = true;
	if (settings.liveInstanceRangeCount > 0) {
		if (settings.liveInstanceRangeCount == 1) {
			// Just check if we're inside range:
			const uint64_t liveInstanceRangeBuffer = settings.liveInstanceRangeBufferOrSegmentTreeSize;
			const uint firstIndex = LiveInstanceRangeBuffers(nonuniformEXT(
				instanceId * settings.firstInstanceIndexStride + settings.firstInstanceIndexOffset + liveInstanceRangeBuffer)).value;
			const uint instanceCount = LiveInstanceRangeBuffers(nonuniformEXT(
				instanceId * settings.instanceCountStride + settings.instanceCountOffset + liveInstanceRangeBuffer)).value;
			const uint lastIndex = (firstIndex + instanceCount);
			instanceLive = (instanceId >= firstIndex) && (instanceId < lastIndex);
		}
		else {
			// Check index-sum to determine what's what:
			instanceLive = EvaluateSegmentTreeRange(
				settings.liveRangeStart, settings.liveRangeStart + instanceId,
				uint(settings.liveInstanceRangeBufferOrSegmentTreeSize)) > 0;
		}
	}
}


#define COMBINED_SIMULATION_KERNEL_BINDING_SET 1
#define COMBINED_SIMULATION_KERNEL_BINDING 1
#include "../../../GraphicsSimulation/CombinedGraphicsSimulationKernel_Body.glh"
