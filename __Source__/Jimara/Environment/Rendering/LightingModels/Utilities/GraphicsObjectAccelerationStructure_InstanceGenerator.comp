#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : require
#include "../../Algorithms/SegmentTree/SegmentTree.glh"
#include "../../../../Graphics/Memory/Jimara_AccelerationStructures.glh"

layout (set = 0, binding = 0) buffer readonly SegmentTreeBuffer {
	int[] values;
} segmentTreeBuffer;

layout (set = 0, binding = 1) buffer InstanceDescriptors {
	Jimara_AccelerationStructureInstanceDesc[] values;
} instanceDescriptors;

layout (set = 0, binding = 2) buffer readonly BlasReferenceBuffer {
	uint64_t[] values;
} blasReferenceBuffer;

int EvaluateSegmentTreeRange(uint start, uint end, uint segmentTreeSize) {
	int value = 0;
	#define Jimara_SegmentTree_IncorporateFn(index) value += segmentTreeBuffer.values[index];
	Jimara_SegmentTree_IncorporateRange(start, end, segmentTreeSize, Jimara_SegmentTree_IncorporateFn)
	#undef Jimara_SegmentTree_IncorporateFn
	return value;
}

struct SimulationTaskSettings {
	uint64_t liveInstanceRangeBufferOrSegmentTreeSize;		// Bytes [0 - 8)
	uint firstInstanceIndexOffset;							// Bytes [8 - 12)
	uint instanceCountOffset;								// Bytes [12 - 16)

	uint liveRangeStart;									// Bytes [16 - 24)
	uint taskThreadCount;									// Bytes [24 - 28)

	uint64_t jm_objectTransformBuffer;						// Bytes [28 - 36)
	uint jm_objectTransformBufferStride;					// Bytes [36 - 40)
	
	uint liveInstanceRangeCount;							// Bytes [40 - 44)

	// If blasCount is 1, blasReference is direct reference, otherwise, we'll have per-instance entries and it'll be a buffer element address.
	uint64_t blasReference;									// Bytes [44 - 48)
	uint blasCount;											// Bytes [48 - 52)

	// Instance custom index and visibility-mask for the BLAS instances.
	uint instanceCustomIndex24_visibilityMask8;				// Bytes [52 - 56)

	// SBT and instance flags for the BLAS instances.
	uint shaderBindingTableRecordOffset24_instanceFlags8;	// Bytes [56 - 60)

	uint firstInstanceIndex;								// Bytes [60 - 64)
};

layout(buffer_reference) buffer readonly LiveInstanceRangeBuffers { uint value; };
layout(buffer_reference) buffer readonly InstanceTransformBuffers { mat4 value; };

uint Jimara_CombinedGraphicsSimulationKernel_TaskIndex();

void ExecuteSimulationTask(in const SimulationTaskSettings settings, uint instanceId) {
	// Check if given instance is alive:
	bool instanceLive = (settings.blasCount > 0 && settings.blasReference != 0);
	if (settings.liveInstanceRangeCount > 0 && instanceLive) {
		if (settings.liveInstanceRangeCount == 1) {
			// Just check if we're inside range:
			const uint64_t liveInstanceRangeBuffer = settings.liveInstanceRangeBufferOrSegmentTreeSize;
			const uint firstIndex = LiveInstanceRangeBuffers(nonuniformEXT(
				settings.firstInstanceIndexOffset + liveInstanceRangeBuffer)).value;
			const uint instanceCount = LiveInstanceRangeBuffers(nonuniformEXT(
				settings.instanceCountOffset + liveInstanceRangeBuffer)).value;
			const uint lastIndex = (firstIndex + instanceCount);
			instanceLive = (instanceId >= firstIndex) && (instanceId < lastIndex);
		}
		else {
			// Check index-sum to determine what's what:
			instanceLive = EvaluateSegmentTreeRange(
				settings.liveRangeStart, settings.liveRangeStart + instanceId,
				uint(settings.liveInstanceRangeBufferOrSegmentTreeSize)) > 0;
		}
	}
	//instanceLive = true;

	Jimara_AccelerationStructureInstanceDesc instanceDesc;

	// Set matrix:
	{
		const mat4 matrix = InstanceTransformBuffers(nonuniformEXT(
			settings.jm_objectTransformBuffer + instanceId * settings.jm_objectTransformBufferStride)).value;
		const mat4 transposed = transpose(matrix);
		instanceDesc.transform[0] = transposed[0];
		instanceDesc.transform[1] = transposed[1];
		instanceDesc.transform[2] = transposed[2];
	}

	// Set mask, flags and alike:
	{
		instanceDesc.instanceCustomIndex24_visibilityMask8 = settings.instanceCustomIndex24_visibilityMask8;
		instanceDesc.shaderBindingTableRecordOffset24_instanceFlags8 = settings.shaderBindingTableRecordOffset24_instanceFlags8;
	}

	// Set blas:
	if (instanceLive) {
		if (settings.blasCount > 1) {
			if (instanceId >= settings.blasCount)
				instanceDesc.blasDeviceAddress = 0;
			else instanceDesc.blasDeviceAddress = blasReferenceBuffer.values[uint(settings.blasReference) + instanceId];
		}
		else instanceDesc.blasDeviceAddress = settings.blasReference;
	}
	else instanceDesc.blasDeviceAddress = 0;

	// Store results:
	const uint globalInstanceIndex = settings.firstInstanceIndex + instanceId; //gl_GlobalInvocationID.x;
	instanceDescriptors.values[globalInstanceIndex] = instanceDesc;
}


#define COMBINED_SIMULATION_KERNEL_BINDING_SET 1
#define COMBINED_SIMULATION_KERNEL_BINDING 1
#include "../../../GraphicsSimulation/CombinedGraphicsSimulationKernel_Body.glh"
