#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : require
#include "../../Algorithms/SegmentTree/SegmentTree.glh"
#include "../../../../Graphics/Memory/Jimara_AccelerationStructures.glh"

layout (set = 0, binding = 0) buffer readonly SegmentTreeBuffer {
	int[] values;
} segmentTreeBuffer;

layout (set = 0, binding = 1) buffer InstanceDescriptors {
	Jimara_AccelerationStructureInstanceDesc[] values;
} instanceDescriptors;

layout (set = 0, binding = 2) buffer readonly BlasReferenceBuffer {
	uint64_t[] values;
} blasReferenceBuffer;

int EvaluateSegmentTreeRange(uint start, uint end, uint segmentTreeSize) {
	int value = 0;
	#define Jimara_SegmentTree_IncorporateFn(index) value += segmentTreeBuffer.values[index];
	Jimara_SegmentTree_IncorporateRange(start, end, segmentTreeSize, Jimara_SegmentTree_IncorporateFn)
	#undef Jimara_SegmentTree_IncorporateFn
	return value;
}

// Live range flags:
#define LIVE_RANGES_NOT_PRESENT 0
#define SINGLE_LIVE_RANGE 1
#define MULTIPLE_LIVE_RANGES 2

struct SimulationTaskSettings {
	uint64_t liveInstanceRangeBufferOrSegmentTreeSize;	// Bytes [0 - 8)
	uint firstInstanceIndexOffset;						// Bytes [8 - 12)
	uint firstInstanceIndexStride;						// Bytes [12 - 16)
	uint instanceCountOffset;							// Bytes [16 - 20)
	uint instanceCountStride;							// Bytes [20 - 24)

	uint liveRangeStart;								// Bytes [24 - 28)
	uint taskThreadCount;								// Bytes [28 - 32)

	uint64_t jm_objectTransformBuffer;					// Bytes [32 - 40)
	uint jm_objectTransformBufferStride;				// Bytes [40 - 44)
	
	// (liveRangeFlags << 16) + (visibilityMask << 8) + instanceFlags
	uint liveRange_visibilityMask_instanceFlags;		// Bytes [44 - 48)

	// If blasCount is 1, blasReference is direct reference, otherwise, we'll have per-instance entries and it'll be a buffer element address.
	uint64_t blasReference;								// Bytes [48 - 56)
	uint blasCount;										// Bytes [56 - 60)

	uint bindingTableRecordOffset;						// Bytes [60 - 64)
};

layout(buffer_reference) buffer readonly LiveInstanceRangeBuffers { uint value; };
layout(buffer_reference) buffer readonly InstanceTransformBuffers { mat4 value; };

uint Jimara_CombinedGraphicsSimulationKernel_TaskIndex();

void ExecuteSimulationTask(in const SimulationTaskSettings settings, uint instanceId) {
	// Check if given instance is alive:
	bool instanceLive = (settings.blasCount > 0 && settings.blasReference != 0);
	const uint liveRangeFlags = (settings.liveRange_visibilityMask_instanceFlags >> 16) & 255;
	if (liveRangeFlags != LIVE_RANGES_NOT_PRESENT && instanceLive) {
		if (liveRangeFlags == SINGLE_LIVE_RANGE) {
			// Just check if we're inside range:
			const uint64_t liveInstanceRangeBuffer = settings.liveInstanceRangeBufferOrSegmentTreeSize;
			const uint firstIndex = LiveInstanceRangeBuffers(nonuniformEXT(
				instanceId * settings.firstInstanceIndexStride + settings.firstInstanceIndexOffset + liveInstanceRangeBuffer)).value;
			const uint instanceCount = LiveInstanceRangeBuffers(nonuniformEXT(
				instanceId * settings.instanceCountStride + settings.instanceCountOffset + liveInstanceRangeBuffer)).value;
			const uint lastIndex = (firstIndex + instanceCount);
			instanceLive = (instanceId >= firstIndex) && (instanceId < lastIndex);
		}
		else {
			// Check index-sum to determine what's what:
			instanceLive = EvaluateSegmentTreeRange(
				settings.liveRangeStart, settings.liveRangeStart + instanceId,
				uint(settings.liveInstanceRangeBufferOrSegmentTreeSize)) > 0;
		}
	}

	Jimara_AccelerationStructureInstanceDesc instanceDesc;

	// Set matrix:
	{
		const mat4 matrix = InstanceTransformBuffers(nonuniformEXT(
			settings.jm_objectTransformBuffer + instanceId * settings.jm_objectTransformBufferStride)).value;
		const mat4 transposed = transpose(matrix);
		instanceDesc.transform[0] = transposed[0];
		instanceDesc.transform[1] = transposed[1];
		instanceDesc.transform[2] = transposed[2];
	}

	// Set mask, flags and alike:
	{
		const uint visibilityMask = instanceLive ? ((settings.liveRange_visibilityMask_instanceFlags >> 8) & 255) : 0;
		SetInstanceCustomIndex(instanceDesc, instanceLive ? Jimara_CombinedGraphicsSimulationKernel_TaskIndex() : 0);
		SetVisibilityMask(instanceDesc, visibilityMask);
		const uint instanceFlags = instanceLive ? (settings.liveRange_visibilityMask_instanceFlags & 255) : 0;
		SetShaderBindingTableRecordOffset(instanceDesc, settings.bindingTableRecordOffset);
		SetInstanceFlags(instanceDesc, instanceFlags);
	}

	// Set blas:
	if (instanceLive) {
		if (settings.blasCount > 1) {
			if (instanceId >= settings.blasCount)
				instanceDesc.blasDeviceAddress = 0;
			else instanceDesc.blasDeviceAddress = blasReferenceBuffer.values[uint(settings.blasReference) + instanceId];
		}
		else instanceDesc.blasDeviceAddress = settings.blasReference;
	}
	else instanceDesc.blasDeviceAddress = 0;

	// Store results:
	const uint globalInstanceIndex = gl_GlobalInvocationID.x;
	instanceDescriptors.values[globalInstanceIndex] = instanceDesc;
}


#define COMBINED_SIMULATION_KERNEL_BINDING_SET 1
#define COMBINED_SIMULATION_KERNEL_BINDING 1
#include "../../../GraphicsSimulation/CombinedGraphicsSimulationKernel_Body.glh"
