
/** _________________________________________________________________________________________________________ */
/** ############################################ RAY-GENERATION: ############################################ */
#pragma JM_LightingModelStage RayGeneration JM_RayGenShader, JM_NoLitShader;
#if RayGeneration

layout(set = MODEL_BINDING_SET_ID, binding = JIMARA_RT_MODEL_BINDING_BASE, rgba32ui) uniform readonly uimage2D JM_RayTracedRenderer_primitiveRecordId;
layout(set = MODEL_BINDING_SET_ID, binding = (JIMARA_RT_MODEL_BINDING_BASE + 1)) uniform writeonly image2D JM_RayTracedRenderer_frameColor;

layout(location = 0) callableDataEXT Jimara_RayTracedRenderer_ShadeFragment_Call_Payload jimara_RayTracedRenderer_ShadeFragment_Call_Payload;

vec2 CalculateRasteredFaceBarycentrics(
	uint objectPrimitiveId, uint objectInstanceId, 
	in const Jimara_RayTracedRenderer_PerObjectData objectData, 
	in const vec2 frameUV) {
	
	// TODO: If we want to support vertex-displacement, this should be susbtituted by a callable.

	// Vertex A in clip-space:
	uint vertId = JM_StandardVertexInput_uint(nonuniformEXT(12 * objectPrimitiveId + objectData.indexBufferId)).value;	
	mat4 transform = Jimara_CameraTransform() * JM_GetObjectTransform(objectData.vertexInput, vertId, objectInstanceId);
	vec4 vertPos = vec4(JM_GetVertexPosition(objectData.vertexInput, vertId, objectInstanceId), 1.0);
	vertPos = transform * vertPos;
	vec2 aUV = vec2(vertPos.x / vertPos.w, vertPos.y / vertPos.w);

	// Vertex B in clip-space:
	vertId = JM_StandardVertexInput_uint(nonuniformEXT(12 * objectPrimitiveId + objectData.indexBufferId + 4)).value;	
	if (((objectData.vertexInput.objectTransform.flags >> JM_StandardVertexInputRate_PerVertexBit) & 1) != 0)
		transform = Jimara_CameraTransform() * JM_GetObjectTransform(objectData.vertexInput, vertId, objectInstanceId);
	vertPos = vec4(JM_GetVertexPosition(objectData.vertexInput, vertId, objectInstanceId), 1.0);
	vertPos = transform * vertPos;
	vec2 bUV = vec2(vertPos.x / vertPos.w, vertPos.y / vertPos.w);

	// Vertex C in clip-space:
	vertId = JM_StandardVertexInput_uint(nonuniformEXT(12 * objectPrimitiveId + objectData.indexBufferId + 8)).value;	
	if (((objectData.vertexInput.objectTransform.flags >> JM_StandardVertexInputRate_PerVertexBit) & 1) != 0)
		transform = Jimara_CameraTransform() * JM_GetObjectTransform(objectData.vertexInput, vertId, objectInstanceId);
	vertPos = vec4(JM_GetVertexPosition(objectData.vertexInput, vertId, objectInstanceId), 1.0);
	vertPos = transform * vertPos;
	vec2 fUV = vec2(vertPos.x / vertPos.w, vertPos.y / vertPos.w); // Temporarily store absolute position of C here..
	
	// Translate aUV, bUV and frameUV in a way that cUV is the origin:
	aUV -= fUV;
	bUV -= fUV;
	fUV = frameUV - fUV;
	
	// Calculate barycentrics:
	// { 
	//	fUV.x = x * aUV.x + y * bUV.x;
	//	fUV.y = x * aUV.y + y * bUV.y;
	// } => {
	//	fUV.x * bUV.y = x * aUV.x * bUV.y + y * bUV.x * bUV.y;
	//	fUV.y * bUV.x = x * aUV.y * bUV.x + y * bUV.y * bUV.x;
	// } => (fUV.x * bUV.y - fUV.y * bUV.x) = (x * aUV.x * bUV.y + y * bUV.x * bUV.y) - (x * aUV.y * bUV.x + y * bUV.y * bUV.x) =>
	// => (fUV.x * bUV.y - fUV.y * bUV.x) = x * (aUV.x * bUV.y - aUV.y * bUV.x) =>
	// => {
	//  x = (fUV.x * bUV.y - fUV.y * bUV.x) / (aUV.x * bUV.y - aUV.y * bUV.x);
	//  y = ((fUV.x - x * aUV.x) / bUV.x) or ((fUV.y - x * aUV.y) / bUV.y);
	// }

	// TODO: Clip-Space barycentrics do not seem all that stable...

	float div = (aUV.x * bUV.y - aUV.y * bUV.x);
	vec2 barycentrics;
	if (abs(div) > 0.0000000001)
		barycentrics.x = (fUV.x * bUV.y - fUV.y * bUV.x) / div;
	else barycentrics.x = 0.0;

	if (abs(bUV.x) > 0.0000000001)
		barycentrics.y = ((fUV.x - barycentrics.x * aUV.x) / bUV.x);
	else if (abs(bUV.y) > 0.0000000001)
		barycentrics.y = ((fUV.y - barycentrics.x * aUV.y) / bUV.y);
	else barycentrics.y = (1 - barycentrics.x);
	
	// Return YZ barycentrics:
	return vec2(barycentrics.y, 1.0 - barycentrics.x - barycentrics.y);
}

void main() {
	const ivec2 pixelIndex = ivec2(gl_LaunchIDEXT.xy);
	const ivec2 targetSize = ivec2(imageSize(JM_RayTracedRenderer_frameColor));

	//const float frameUV_Start = vec2(pixelIndex) / vec2(targetSize);
	//const float frameUV_End = (vec2(pixelIndex) + 1.0) / vec2(targetSize);

	const uvec4 primitiveRecordId = imageLoad(JM_RayTracedRenderer_primitiveRecordId, pixelIndex);
	const uint objectInstanceId = primitiveRecordId.x;
	const uint objectPrimitiveId = primitiveRecordId.y;
	const uint drawnObjectId = primitiveRecordId.z;

	if (drawnObjectId == ~uint(0))
		return;

	Jimara_RayTracedRenderer_PerObjectData objectData = jimara_RayTracedRenderer_SceneObjectData.objectData[drawnObjectId];

	if (objectData.materialId == JM_RT_FLAG_MATERIAL_NOT_IN_RT_PIPELINE) {
		Jimara_RNG_t rng;
		JIMARA_RNG_seed(rng, objectInstanceId + 1, ~drawnObjectId + 4, objectPrimitiveId + 64, objectInstanceId + 8, drawnObjectId + 32);
		for (uint i = 0; i < 64; i++)
			Jimara_RNG_float(rng);
		vec3 color = vec3(Jimara_RNG_float(rng), Jimara_RNG_float(rng), Jimara_RNG_float(rng));
		imageStore(JM_RayTracedRenderer_frameColor, pixelIndex, vec4(color, 1.0));
		return;
	}

	// __TODO__: We need a way to render edges too..
	if ((objectData.flags & JM_RT_FLAG_EDGES) != 0)
		return;

	vec2 barycentrics = CalculateRasteredFaceBarycentrics(
		objectPrimitiveId, objectInstanceId, objectData, 
		((vec2(pixelIndex) / (vec2(max(targetSize.x, 2), max(targetSize.y, 2)) - vec2(1.0, 1.0))) - vec2(0.5, 0.5)) * vec2(2.0, -2.0));

	jimara_RayTracedRenderer_ShadeFragment_Call_Payload.fragmentData.barycentrics = barycentrics;
	jimara_RayTracedRenderer_ShadeFragment_Call_Payload.fragmentData.objectPrimitiveId = objectPrimitiveId;
	jimara_RayTracedRenderer_ShadeFragment_Call_Payload.fragmentData.objectInstanceId = objectInstanceId;
	jimara_RayTracedRenderer_ShadeFragment_Call_Payload.fragmentData.drawnObjectId = drawnObjectId;
	jimara_RayTracedRenderer_ShadeFragment_Call_Payload.eyePosition = Jimara_ViewPose()[3].xyz;
	jimara_RayTracedRenderer_ShadeFragment_Call_Payload.fragmentColor = vec4(0.0, 0.0, 0.0, 0.0);
	executeCallableEXT(objectData.materialId, 0);

	imageStore(JM_RayTracedRenderer_frameColor, pixelIndex, jimara_RayTracedRenderer_ShadeFragment_Call_Payload.fragmentColor);

	// __TODO__: Get back JM_RayTracedRenderer_instanceId, gl_PrimitiveID and Drawn-Object index from JM_RayTracedRenderer_primitiveRecordId;
	// __TODO__: Get back gl_FragCoord from JM_RayTracedRenderer_clipSpacePosition;
	// __TODO__: Based on geometry and projection, restore barycentric coordinates;
	// __TODO__: Find material-id, as well as settings-buffer index based on the Drawn-Object index;
	// __TODO__: Invoke JM_Init callable function that 'simulates' derivatives;
	// __TODO__: Accumulate direct-light;
	// __TODO__: Iterate on bounce samples.... (later)
}
#endif // RayGeneration
