
/** _________________________________________________________________________________________________________ */
/** ############################################ RAY-GENERATION: ############################################ */
#pragma JM_LightingModelStage RayGeneration JM_RayGenShader, JM_NoLitShader;
#if RayGeneration

layout(set = MODEL_BINDING_SET_ID, binding = JIMARA_RT_MODEL_BINDING_BASE, rgba32ui) uniform readonly uimage2D JM_RayTracedRenderer_primitiveRecordId;
layout(set = MODEL_BINDING_SET_ID, binding = (JIMARA_RT_MODEL_BINDING_BASE + 1)) uniform writeonly image2D JM_RayTracedRenderer_frameColor;

layout(set = MODEL_BINDING_SET_ID, binding = (JIMARA_RT_MODEL_BINDING_BASE + 2)) uniform accelerationStructureEXT JM_RayTracedRenderer_tlas;

layout(location = 0) callableDataEXT Jimara_RayTracedRenderer_Standard_Call_Payload jimara_RayTracedRenderer_Call_Payload;

vec2 CalculateRasteredFaceBarycentrics(
	uint objectPrimitiveId, uint objectInstanceId, 
	in const Jimara_RayTracedRenderer_PerObjectData objectData, 
	in const vec2 frameUV) {
	
	// TODO: If we want to support vertex-displacement, this should be susbtituted by a callable.
	
	// Fragment-direction:
	const vec4 viewDir =  jimara_RayTracedRenderer_ViewportBuffer.inverseProjection * vec4(frameUV, 1.0, 1.0);
	const vec3 fragDirection = (viewDir.xyz / viewDir.w);

	// Vertex A in view-space:
	uint vertId = JM_StandardVertexInput_uint(nonuniformEXT(12 * objectPrimitiveId + objectData.indexBufferId)).value;	
	mat4 transform = Jimara_ViewMatrix() * JM_GetObjectTransform(objectData.vertexInput, vertId, objectInstanceId);
	const vec3 vertPosA = (transform * vec4(JM_GetVertexPosition(objectData.vertexInput, vertId, objectInstanceId), 1.0)).xyz;
	
	// Vertex B in view-space:
	vertId = JM_StandardVertexInput_uint(nonuniformEXT(12 * objectPrimitiveId + objectData.indexBufferId + 4)).value;	
	if (objectData.vertexInput.objectTransform.perVertexStride > 0)
		transform = Jimara_ViewMatrix() * JM_GetObjectTransform(objectData.vertexInput, vertId, objectInstanceId);
	const vec3 vertPosB = (transform * vec4(JM_GetVertexPosition(objectData.vertexInput, vertId, objectInstanceId), 1.0)).xyz;
	
	// Vertex C in view-space:
	vertId = JM_StandardVertexInput_uint(nonuniformEXT(12 * objectPrimitiveId + objectData.indexBufferId + 8)).value;	
	if (objectData.vertexInput.objectTransform.perVertexStride > 0)
		transform = Jimara_ViewMatrix() * JM_GetObjectTransform(objectData.vertexInput, vertId, objectInstanceId);
	const vec3 vertPosC = (transform * vec4(JM_GetVertexPosition(objectData.vertexInput, vertId, objectInstanceId), 1.0)).xyz;
	
	// Find surface intersectionPoint:
	const vec3 faceNormal = cross(vertPosB - vertPosA, vertPosC - vertPosA);
	const float deltaProjection = dot(vertPosA, faceNormal);
	const float dirProjection = dot(fragDirection, faceNormal);
	if (abs(dirProjection) <= 0.0) 
		return vec2(0.0, 0.0);
	const vec3 hitPoint = fragDirection * (deltaProjection / dirProjection);

	// Calculate barycentrics:
	const vec3 b = vertPosB - vertPosA;
	const vec3 c = vertPosC - vertPosA;
	const vec3 h = hitPoint - vertPosA;
	float bBB = dot(b, b);
	float dBC = dot(b, c);
	float dCC = dot(c, c);
	float dBH = dot(h, b);
	float dCH = dot(h, c);
	float div = bBB * dCC - dBC * dBC;
	if (abs(div) <= 0.0)
		return vec2(0, 0);
	const float mul = (1.0 / div);
	return vec2(
		(dCC * dBH - dBC * dCH) * mul,
		(bBB * dCH - dBC * dBH) * mul);
}

#define JM_RT_GetFragmentData(JM_RT_GetFragmentData_objectData, JM_RT_GetFragmentData_FragInfo, JM_RT_GetFragmentData_Query, JM_RT_GetFragmentData_committed) { \
	JM_RT_GetFragmentData_FragInfo.drawnObjectId = jimara_RayTracedRenderer_ViewportBuffer.rasterizedGeometrySize + \
		uint(rayQueryGetIntersectionInstanceCustomIndexEXT(JM_RT_GetFragmentData_Query, JM_RT_GetFragmentData_committed)); \
	JM_RT_GetFragmentData_FragInfo.barycentrics = rayQueryGetIntersectionBarycentricsEXT(JM_RT_GetFragmentData_Query, JM_RT_GetFragmentData_committed); \
	JM_RT_GetFragmentData_FragInfo.objectPrimitiveId = uint(rayQueryGetIntersectionPrimitiveIndexEXT(JM_RT_GetFragmentData_Query, JM_RT_GetFragmentData_committed)); \
	JM_RT_GetFragmentData_objectData = jimara_RayTracedRenderer_SceneObjectData.objectData[JM_RT_GetFragmentData_FragInfo.drawnObjectId]; \
	JM_RT_GetFragmentData_FragInfo.objectInstanceId = \
		uint(rayQueryGetIntersectionInstanceIdEXT(JM_RT_GetFragmentData_Query, JM_RT_GetFragmentData_committed)) - \
		JM_RT_GetFragmentData_objectData.firstBlasInstance; \
}

MaterialId_t GenerateFirstHitPayload(vec3 origin, vec3 dir, float minT, float maxT) {
	dir = normalize(dir);
	rayQueryEXT query;
	rayQueryInitializeEXT(
		query, JM_RayTracedRenderer_tlas,
		gl_RayFlagsCullBackFacingTrianglesEXT,
		0xFF, origin, minT, dir, maxT);
	while(rayQueryProceedEXT(query)) {
		// Get data:
		Jimara_RayTracedRenderer_PerObjectData objectData;
		JM_RT_GetFragmentData(objectData, jimara_RayTracedRenderer_Call_Payload.fragmentData, query, false);
		// No need to fill anything else from here; flags are called by the callable itself.

		// Discard if fragment should be discarded:
		executeCallableEXT(objectData.materialId * CALLABLE_STRIDE_PER_MATERIAL + CALLABLE_OFFSET_TRANSPARENCY_QUERY_CALL, 0);
		if ((jimara_RayTracedRenderer_Call_Payload.flags & JM_RT_PAYLOAD_FLAGS_DISCARD_POINT) != 0)
			continue;

		// Any-hit success:
		rayQueryConfirmIntersectionEXT(query);
	}
	if (rayQueryGetIntersectionTypeEXT(query, true) != 0) {
		// Get data:
		Jimara_RayTracedRenderer_PerObjectData objectData;
		JM_RT_GetFragmentData(objectData, jimara_RayTracedRenderer_Call_Payload.fragmentData, query, true);

		// Return material-id:
		return objectData.materialId;
	}
	// No hit - no material:
	else return INVALID_MATERIAL_ID;
}

MaterialId_t GeneratePixelPayload_FirstHit(in const ivec2 pixelIndex, in const ivec2 targetSize) {
	const vec2 frameUV = ((vec2(pixelIndex) / (vec2(max(targetSize.x, 2), max(targetSize.y, 2)) - vec2(1.0, 1.0))) - vec2(0.5, 0.5)) * vec2(2.0, -2.0);
	const vec4 viewDir =  jimara_RayTracedRenderer_ViewportBuffer.inverseProjection * vec4(frameUV, 1.0, 1.0);
	const vec3 fragDirection = (Jimara_ViewPose() * vec4(viewDir.xyz / viewDir.w, 0.0)).xyz;

	const vec3 dir = normalize(fragDirection);
	const vec3 viewPos = Jimara_ViewPose()[3].xyz;
	const float minT = 0.0001;

	return GenerateFirstHitPayload(viewPos, dir, minT, 
		jimara_RayTracedRenderer_ViewportBuffer.accelerationStructureRange);
}

MaterialId_t GeneratePixelPayload_FromVBuffer(in const ivec2 pixelIndex, in const ivec2 targetSize) {
	const uvec4 primitiveRecordId = imageLoad(JM_RayTracedRenderer_primitiveRecordId, pixelIndex);
	const uint objectInstanceId = primitiveRecordId.x;
	const uint objectPrimitiveId = primitiveRecordId.y;
	const uint drawnObjectId = primitiveRecordId.z;

	if (drawnObjectId == ~uint(0))
		return INVALID_MATERIAL_ID;

	Jimara_RayTracedRenderer_PerObjectData objectData = jimara_RayTracedRenderer_SceneObjectData.objectData[drawnObjectId];

	// __TODO__: We need a way to render edges too..
	if ((objectData.flags & JM_RT_FLAG_EDGES) != 0)
		return INVALID_MATERIAL_ID;

	vec2 barycentrics = CalculateRasteredFaceBarycentrics(
		objectPrimitiveId, objectInstanceId, objectData, 
		((vec2(pixelIndex) / (vec2(max(targetSize.x, 2), max(targetSize.y, 2)) - vec2(1.0, 1.0))) - vec2(0.5, 0.5)) * vec2(2.0, -2.0));

	jimara_RayTracedRenderer_Call_Payload.fragmentData.barycentrics = barycentrics;
	jimara_RayTracedRenderer_Call_Payload.fragmentData.objectPrimitiveId = objectPrimitiveId;
	jimara_RayTracedRenderer_Call_Payload.fragmentData.objectInstanceId = objectInstanceId;
	jimara_RayTracedRenderer_Call_Payload.fragmentData.drawnObjectId = drawnObjectId;

	// If init fails, we should default to the first-hit:
	// Discard if fragment should be discarded:
	if ((jimara_RayTracedRenderer_ViewportBuffer.renderFlags & RENDERER_FLAGS_FALLBACK_ON_FIRST_RAY_IF_VBUFFER_EVAL_FAILS) != 0 &&
		(objectData.flags & JM_RT_FLAG_CAN_DISCARD) != 0) {
		executeCallableEXT(objectData.materialId * CALLABLE_STRIDE_PER_MATERIAL + CALLABLE_OFFSET_TRANSPARENCY_QUERY_CALL, 0);
		if ((jimara_RayTracedRenderer_Call_Payload.flags & JM_RT_PAYLOAD_FLAGS_DISCARD_POINT) != 0)
			return GeneratePixelPayload_FirstHit(pixelIndex, targetSize);
	}

	return objectData.materialId;
}

MaterialId_t GeneratePixelPayload() {
	const ivec2 pixelIndex = ivec2(gl_LaunchIDEXT.xy);
	const ivec2 targetSize = ivec2(imageSize(JM_RayTracedRenderer_frameColor));

	if ((jimara_RayTracedRenderer_ViewportBuffer.renderFlags & RENDERER_FLAGS_USE_RASTER_VBUFFER) != 0)
		return GeneratePixelPayload_FromVBuffer(pixelIndex, targetSize);
	else return GeneratePixelPayload_FirstHit(pixelIndex, targetSize);
}

void main() {
	// Establish first payload:
	MaterialId_t materialId = GeneratePixelPayload();
	if (materialId == INVALID_MATERIAL_ID)
		return;
	
	// Fragment color and sample transmittance will be continually updated, so we need to initialize them here:
	jimara_RayTracedRenderer_Call_Payload.fragmentColor = vec4(0.0, 0.0, 0.0, 1.0);
	jimara_RayTracedRenderer_Call_Payload.sampleTransmittance = mat3(
		vec3(1.0, 0.0, 0.0),
		vec3(0.0, 1.0, 0.0),
		vec3(0.0, 0.0, 1.0));

	// Initial eye-position is the camera-position:
	vec3 eyePosition = Jimara_ViewPose()[3].xyz;

	// Bounce-count countdown:
	uint bouncesLeft = jimara_RayTracedRenderer_ViewportBuffer.maxTraceDepth;

	while (true) {
		// Shade: 
		jimara_RayTracedRenderer_Call_Payload.eyePosition = eyePosition;
		if (bouncesLeft > 0) {
			jimara_RayTracedRenderer_Call_Payload.flags = JM_RT_PAYLOAD_FLAGS_INDIRECT_CAN_REQUEST_SAMPLE;
			bouncesLeft--;
		}
		else jimara_RayTracedRenderer_Call_Payload.flags = 0;
		executeCallableEXT(materialId * CALLABLE_STRIDE_PER_MATERIAL + CALLABLE_OFFSET_SHADE_FRAGMENT_CALL, 0);

		// If indirect sample is requested, update eye-position and material-id:
		if ((jimara_RayTracedRenderer_Call_Payload.flags & JM_RT_PAYLOAD_FLAGS_INDIRECT_SAMPLE_REQUESTED) != 0) {
			eyePosition = jimara_RayTracedRenderer_Call_Payload.eyePosition;
			const float minT = 0.01;
			materialId = GenerateFirstHitPayload(eyePosition, jimara_RayTracedRenderer_Call_Payload.sampleDirection, 
				minT, 
				jimara_RayTracedRenderer_ViewportBuffer.accelerationStructureRange);
			if (materialId == INVALID_MATERIAL_ID)
				break;
			else jimara_RayTracedRenderer_Call_Payload.fragmentColor.xyz -= jimara_RayTracedRenderer_Call_Payload.irradianceColor;
		}
		else break;
	}

	// Store rendered color:
	imageStore(JM_RayTracedRenderer_frameColor, ivec2(gl_LaunchIDEXT.xy), jimara_RayTracedRenderer_Call_Payload.fragmentColor);
}
#endif // RayGeneration
