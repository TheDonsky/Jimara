
// Common input:
layout(set = MODEL_BINDING_SET_ID, binding = MODEL_BINDING_START_ID) uniform Jimara_RayTracedRenderer_ViewportBuffer {
	mat4 view;
	mat4 projection;
	mat4 viewPose;
} jimara_RayTracedRenderer_ViewportBuffer;

mat4 Jimara_ViewMatrix() { 
	return jimara_RayTracedRenderer_ViewportBuffer.view;
}

mat4 Jimara_ProjectionMatrix() { 
	return jimara_RayTracedRenderer_ViewportBuffer.projection;
}

mat4 Jimara_CameraTransform() {
	return jimara_RayTracedRenderer_ViewportBuffer.projection * jimara_RayTracedRenderer_ViewportBuffer.view;
}

mat4 Jimara_ViewPose() {
	return jimara_RayTracedRenderer_ViewportBuffer.viewPose;
}

struct ObjectDetails {
	uint shaderId;
	uint settingsId;
};


#include "../JM_StandardVertexInputStructure.glh"


/** ______________________________________________________________________________________________________ */
/** ############################################ RASTER-PASS: ############################################ */
#pragma JM_LightingModelStage RasterPass JM_VertexShader, JM_FragmentShader;
#if RasterPass
#define JM_BasicRaster_LM_PerformsAdditionalVertexProcessing
#define JM_BasicRaster_LM_BaseLocationSlot 1
#include "../Jimara_BasicRasterLM_Stages.glh"

/** ------------------ Vertex shader: ---------------------- **/
#if JM_ShaderStage == JM_VertexShader

layout(location = 0) out flat uint JM_RayTracedRenderer_instanceId;

void JM_BasicRaster_ProcessVertex() {
	JM_RayTracedRenderer_instanceId = gl_InstanceIndex;
}

vec4 JM_BasicRaster_WorldToClipSpacePosition(in const vec3 position) {
	return Jimara_CameraTransform() * vec4(position, 1.0);
}

/** ------------------ Vertex shader: ---------------------- **/
#elif JM_ShaderStage == JM_FragmentShader

#if (JM_MaterialFlags & JM_CanDiscard) == 0
// For non-discard, early_fragment_tests can be enabled by default
layout(early_fragment_tests) in;
#endif

layout(location = 0) in flat uint JM_RayTracedRenderer_instanceId;

layout(location = 0) out uvec3 JM_RayTracedRenderer_primitiveRecordId;
layout(location = 3) out vec2 JM_RayTracedRenderer_clipSpacePosition;

void JM_BasicRaster_RenderFragment(in const JM_FragmentData fragInput, in const JM_MaterialProperties materialProperties) {
	JM_ShadingState state;
	const bool initStatus = JM_Init(fragInput, materialProperties, state);
#if (JM_MaterialFlags & JM_CanDiscard) != 0
	if (!initStatus)
		discard;
#endif
	JM_RayTracedRenderer_primitiveRecordId = uvec3(
		JM_RayTracedRenderer_instanceId,
		gl_PrimitiveID,
		0 // __TODO__: Drawn-Object index...
		);
	JM_RayTracedRenderer_clipSpacePosition = gl_FragCoord.xy;
}
#endif
#endif // RasterPass





/** _________________________________________________________________________________________________________ */
/** ############################################ RAY-GENERATION: ############################################ */
#pragma JM_LightingModelStage RayGeneration JM_RayGenShader, JM_NoLitShader;
#if RayGeneration
void main() {
	// __TODO__: Get back JM_RayTracedRenderer_instanceId, gl_PrimitiveID and Drawn-Object index from JM_RayTracedRenderer_primitiveRecordId;
	// __TODO__: Get back gl_FragCoord from JM_RayTracedRenderer_clipSpacePosition;
	// __TODO__: Based on geometry and projection, restore barycentric coordinates;
	// __TODO__: Find material-id, as well as settings-buffer index based on the Drawn-Object index;
	// __TODO__: Invoke JM_Init callable function that 'simulates' derivatives;
	// __TODO__: Accumulate direct-light;
	// __TODO__: Iterate on bounce samples.... (later)
}
#endif // RayGeneration
