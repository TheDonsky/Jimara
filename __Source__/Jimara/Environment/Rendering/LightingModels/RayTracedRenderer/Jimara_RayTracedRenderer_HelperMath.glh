#ifndef JIMARA_RAY_TRACED_RENDERER_MATH_HELPERS_DEFINED
#define JIMARA_RAY_TRACED_RENDERER_MATH_HELPERS_DEFINED

vec3 JM_RT_CalculatePlaneHitPoint(in const vec3 planeOrigin, in const vec3 planeNormal, 
	in const vec3 rayOrigin, in const vec3 rayDirection) {
	const float deltaProjection = dot(planeOrigin - rayOrigin, planeNormal);
	const float dirProjection = dot(rayDirection, planeNormal);
	if (abs(dirProjection) <= 0.0) 
		return planeOrigin;
	return rayOrigin + rayDirection * (deltaProjection / dirProjection);
}

vec3 JM_RT_CalculateHitPoint(in const vec3 vertPosA, in const vec3 vertPosB, in const vec3 vertPosC, 
	in const vec3 rayOrigin, in const vec3 rayDirection) {
	return JM_RT_CalculatePlaneHitPoint(vertPosA, cross(vertPosB - vertPosA, vertPosC - vertPosA), rayOrigin, rayDirection);
}

vec2 JM_RT_CalculateBarycentrics(in const vec3 vertPosA, in const vec3 vertPosB, in const vec3 vertPosC, in const vec3 point) {
	const vec3 b = vertPosB - vertPosA;
	const vec3 c = vertPosC - vertPosA;
	const vec3 h = point - vertPosA;
	float bBB = dot(b, b);
	float dBC = dot(b, c);
	float dCC = dot(c, c);
	float dBH = dot(h, b);
	float dCH = dot(h, c);
	float div = bBB * dCC - dBC * dBC;
	if (abs(div) <= 0.0)
		return vec2(0, 0);
	const float mul = (1.0 / div);
	return vec2(
		(dCC * dBH - dBC * dCH) * mul,
		(bBB * dCH - dBC * dBH) * mul);
}

vec2 JM_RT_CalculateHitBarycentrics(
	in const vec3 vertPosA, in const vec3 vertPosB, in const vec3 vertPosC, 
	in const vec3 rayOrigin, in const vec3 rayDirection) {
	
	// Find surface intersectionPoint:
	const vec3 hitPoint = JM_RT_CalculateHitPoint(vertPosA, vertPosB, vertPosC, rayOrigin, rayDirection);

	// Calculate barycentrics:
	return JM_RT_CalculateBarycentrics(vertPosA, vertPosB, vertPosC, hitPoint);
}

void JM_RT_GetVertexPositions(
	uint objectPrimitiveId, uint objectInstanceId, 
	in const Jimara_RayTracedRenderer_PerObjectData objectData,
	out vec3 vertPosA, out vec3 vertPosB, out vec3 vertPosC) {
	// TODO: If we want to support vertex-displacement, this should be susbtituted by a callable.

	// Vertex A in world-space:
	uint vertId = JM_StandardVertexInput_uint(nonuniformEXT(12 * objectPrimitiveId + objectData.indexBufferId)).value;	
	mat4 transform = JM_GetObjectTransform(objectData.vertexInput, vertId, objectInstanceId);
	vertPosA = (transform * vec4(JM_GetVertexPosition(objectData.vertexInput, vertId, objectInstanceId), 1.0)).xyz;
	
	// Vertex B in world-space:
	vertId = JM_StandardVertexInput_uint(nonuniformEXT(12 * objectPrimitiveId + objectData.indexBufferId + 4)).value;	
	if (objectData.vertexInput.objectTransform.perVertexStride > 0)
		transform = JM_GetObjectTransform(objectData.vertexInput, vertId, objectInstanceId);
	vertPosB = (transform * vec4(JM_GetVertexPosition(objectData.vertexInput, vertId, objectInstanceId), 1.0)).xyz;
	
	// Vertex C in world-space:
	vertId = JM_StandardVertexInput_uint(nonuniformEXT(12 * objectPrimitiveId + objectData.indexBufferId + 8)).value;	
	if (objectData.vertexInput.objectTransform.perVertexStride > 0)
		transform = JM_GetObjectTransform(objectData.vertexInput, vertId, objectInstanceId);
	vertPosC = (transform * vec4(JM_GetVertexPosition(objectData.vertexInput, vertId, objectInstanceId), 1.0)).xyz;
}

vec3 JM_RT_FrustrumToWorldPosition(in const vec2 frameUV, float depth) {
	const vec4 viewPos = jimara_RayTracedRenderer_ViewportBuffer.inverseProjection * vec4(frameUV, depth, 1.0);
	return (Jimara_ViewPose() * vec4(viewPos.xyz / viewPos.w, 1.0)).xyz;
}

void JM_RT_CalculateScreenSpaceRay(in const vec2 frameUV, out vec3 origin, out vec3 direction) {
	origin = JM_RT_FrustrumToWorldPosition(frameUV, 0.0);
	direction = JM_RT_FrustrumToWorldPosition(frameUV, 1.0);
	direction = normalize(direction - origin);
}

vec2 JM_RT_CalculateFrustrumSpacePosition(in const vec2 pixelPos, in const vec2 targetSize) {
	return ((pixelPos / targetSize) - 0.5) * vec2(2.0, -2.0);
}

void JM_RT_CalculateConeHit(
	in const vec3 coneOrigin, in const vec3 hitPoint, in const vec3 faceNormal,
	in const float startRadius, in const float radiusOverDistance,
	out vec3 hitDeltaSide, out vec3 hitDeltaUp) {
	
	// Normal and 'side-direction', defined as a direction, perpendicular to ray-direction,
	// shuch that it lies on the plane defined by the ray vector and face normal:
	const vec3 deltaPos = (coneOrigin - hitPoint);
	vec3 sideDir = cross(faceNormal, deltaPos);
	{
		float sideLen = dot(sideDir, sideDir);
		if (sideLen < 0.000000001) {
			sideDir = cross(faceNormal, vec3(1.0, 0.0, 0.0));
			sideLen = dot(sideDir, sideDir);
			if (sideLen < 0.000000001) {
				sideDir = cross(faceNormal, vec3(0.0, 1.0, 0.0));
				sideLen = max(dot(sideDir, sideDir), 0.000000001); // To avoid Nan-s with invalid faces...
			}
		}
		sideDir *= inversesqrt(sideLen);
	}

	const float dist = length(deltaPos);
	float endPointRadius = startRadius + dist * radiusOverDistance;
	hitDeltaSide = sideDir * endPointRadius;

//#define JM_RT_CalculateConeHit_APPROXIMATE_CYLLINDER_HIT
#ifdef JM_RT_CalculateConeHit_APPROXIMATE_CYLLINDER_HIT
	const vec3 upDir = normalize(cross(faceNormal, sideDir));
	endPointRadius *= dist / max(dot(deltaPos, faceNormal), 0.000000001);
	hitDeltaUp = upDir * endPointRadius;

#undef JM_RT_CalculateConeHit_APPROXIMATE_CYLLINDER_HIT
#else
	vec3 upDir = normalize(cross(deltaPos, sideDir));

	vec3 start = upDir * startRadius + coneOrigin;
	vec3 dir = normalize(upDir * endPointRadius + hitPoint - start);
	hitDeltaUp = JM_RT_CalculatePlaneHitPoint(hitPoint, faceNormal, start, dir);

	start = upDir * (-startRadius) + coneOrigin;
	dir = normalize(upDir * (-endPointRadius) + hitPoint - start);
	hitDeltaUp = (hitDeltaUp - JM_RT_CalculatePlaneHitPoint(hitPoint, faceNormal, start, dir)) * 0.5;
#endif
}

#endif
