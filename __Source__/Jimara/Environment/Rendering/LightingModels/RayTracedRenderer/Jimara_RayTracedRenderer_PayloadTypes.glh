#include "../../../../Data/Materials/NormalMap.glh"
#include "../../Algorithms/Random/Jimara_RNG.glh"


struct Jimara_RayTracedRenderer_PrimitiveFragmentInfo {
	vec2 barycentrics;			// Bytes [0 - 8)
	uint objectPrimitiveId;		// Bytes [8 - 12)
	uint objectInstanceId;		// Bytes [12 - 16)
	uint drawnObjectId;			// Bytes [16 - 20)
	// TODO: Add 'patch-size'?
};

struct Jimara_RayTracedRenderer_Standard_Call_Payload {
	// Hit-info:
	Jimara_RayTracedRenderer_PrimitiveFragmentInfo fragmentData;
	
	// Ray-origin (in-out):
	vec3 eyePosition;

	// Physical patch-size at ray-origin point (in):
	float startPatchSize;

	// Ray-direction (in-out):
	vec3 sampleDirection;

	// Physical patch-size at hit-point will be (startPatchSize + patchSizeOverDistance * distance) (in):
	float patchSizeOverDistance;

	// Transmittance of given sample (in-out):
	mat3 sampleTransmittance;

	// Cumulative fragment color (in-out):
	vec4 fragmentColor;

	// Cumulative irradiance-color per shader-fragment call (out):
	vec3 irradianceColor;

	// Additional flags:
	uint flags;
};

#define JM_RT_PAYLOAD_FLAGS_NONE 0
#define JM_RT_PAYLOAD_FLAGS_INIT_FAILED 1
#define JM_RT_PAYLOAD_FLAGS_FULLY_TRANSPARENT 2

#define JM_RT_PAYLOAD_FLAGS_DISCARD_POINT \
	( JM_RT_PAYLOAD_FLAGS_INIT_FAILED \
	| JM_RT_PAYLOAD_FLAGS_FULLY_TRANSPARENT)

#define JM_RT_PAYLOAD_FLAGS_INDIRECT_CAN_REQUEST_SAMPLE 4
#define JM_RT_PAYLOAD_FLAGS_INDIRECT_SAMPLE_REQUESTED 8

#define JM_RT_MIN_VALID_OPACITY 0.00001

#define CALLABLE_OFFSET_SHADE_FRAGMENT_CALL 0
#define CALLABLE_OFFSET_TRANSPARENCY_QUERY_CALL 1
#define CALLABLE_STRIDE_PER_MATERIAL 2



#if JM_ShaderStage == JM_CallableShader

layout(location = 0) callableDataInEXT Jimara_RayTracedRenderer_Standard_Call_Payload jimara_RayTracedRenderer_Call_Payload;

layout(buffer_reference) buffer JM_RT_MaterialPropertiesBuffer { JM_MaterialProperties value; };

vec2 jm_rt_dUV_x;
vec2 jm_rt_dUV_y;
vec3 jm_rt_dP_x;
vec3 jm_rt_dP_y;
vec4 JM_RT_SampleTexture_ScaledByUV_PatchSize(in nonuniformEXT sampler2D jm_rt_tex, in const vec2 jm_rt_uv, in const vec2 jm_rt_uvPatchSize) {
	const vec2 jm_rt_imSize = vec2(textureSize(nonuniformEXT(jm_rt_tex), 0)) * jm_rt_uvPatchSize;
	const vec2 jm_rt_dx = jm_rt_dUV_x * jm_rt_imSize;
	const vec2 jm_rt_dy = jm_rt_dUV_y * jm_rt_imSize;
	const float d = max(dot(jm_rt_dx, jm_rt_dx), dot(jm_rt_dy, jm_rt_dy));
	const float lod = max(0.0, log2(d) * 0.5);
	return textureLod(nonuniformEXT(jm_rt_tex), jm_rt_uv, lod);
}
JM_DefineTextureSupportWithBindlessSamplers_CustomSample(jimara_BindlessTextures, nonuniformEXT, JM_RT_SampleTexture_ScaledByUV_PatchSize);

JM_VertexInput JM_RT_GetVertexInput(in const Jimara_RayTracedRenderer_PerObjectData JM_RT_objectData) {
	const uint JM_RT_objectPrimitiveId = jimara_RayTracedRenderer_Call_Payload.fragmentData.objectPrimitiveId;
	const uint JM_RT_instanceId = jimara_RayTracedRenderer_Call_Payload.fragmentData.objectInstanceId;
	const vec2 JM_RT_barycentrics = jimara_RayTracedRenderer_Call_Payload.fragmentData.barycentrics;
	JM_VertexInput JM_RT_vertexInput = JM_InterpolateStandardVertexInput(JM_RT_objectData.vertexInput, 
		JM_StandardVertexInput_uint(nonuniformEXT(12 * JM_RT_objectPrimitiveId + JM_RT_objectData.indexBufferId)).value, 
		JM_StandardVertexInput_uint(nonuniformEXT(12 * JM_RT_objectPrimitiveId + JM_RT_objectData.indexBufferId + 4)).value, 
		JM_StandardVertexInput_uint(nonuniformEXT(12 * JM_RT_objectPrimitiveId + JM_RT_objectData.indexBufferId + 8)).value,
		JM_RT_instanceId, JM_RT_barycentrics);
	return JM_RT_vertexInput;
}

bool JM_RT_InitMaterialState(inout JM_FragmentData JM_RT_fragmentData, inout JM_ShadingState JM_RT_shadingState) {
	JM_MaterialProperties JM_RT_materialProperties;
	{
		const Jimara_RayTracedRenderer_PerObjectData JM_RT_objectData = jimara_RayTracedRenderer_SceneObjectData.
			objectData[nonuniformEXT(jimara_RayTracedRenderer_Call_Payload.fragmentData.drawnObjectId)];

		// Evaluate JM_VertexInput, but also make sure to keep the tangents and scale them accordingly:
		JM_VertexInput jm_rt_vertexInput;
		vec3 jm_rt_InitMaterialState_tangent;
		vec3 jm_rt_InitMaterialState_bitangent;
		{
			jm_rt_vertexInput = JM_GetStandardVertexInput(
				JM_RT_objectData.vertexInput, JM_StandardVertexInput_uint(
					nonuniformEXT(12 * jimara_RayTracedRenderer_Call_Payload.fragmentData.objectPrimitiveId + JM_RT_objectData.indexBufferId)).value, 
				jimara_RayTracedRenderer_Call_Payload.fragmentData.objectInstanceId);
			JM_VertexInput jm_rt_B = JM_GetStandardVertexInput(
				JM_RT_objectData.vertexInput, JM_StandardVertexInput_uint(
					nonuniformEXT(12 * jimara_RayTracedRenderer_Call_Payload.fragmentData.objectPrimitiveId + JM_RT_objectData.indexBufferId + 4)).value, 
				jimara_RayTracedRenderer_Call_Payload.fragmentData.objectInstanceId);
			JM_VertexInput jm_rt_C = JM_GetStandardVertexInput(
				JM_RT_objectData.vertexInput, JM_StandardVertexInput_uint(
					nonuniformEXT(12 * jimara_RayTracedRenderer_Call_Payload.fragmentData.objectPrimitiveId + JM_RT_objectData.indexBufferId + 8)).value, 
				jimara_RayTracedRenderer_Call_Payload.fragmentData.objectInstanceId);
			
			const vec3 jm_rt_weights = vec3(
				1.0 - jimara_RayTracedRenderer_Call_Payload.fragmentData.barycentrics.x - jimara_RayTracedRenderer_Call_Payload.fragmentData.barycentrics.y,
				jimara_RayTracedRenderer_Call_Payload.fragmentData.barycentrics.x, jimara_RayTracedRenderer_Call_Payload.fragmentData.barycentrics.y);

			if (JM_RT_objectData.vertexInput.objectTransform.perVertexStride > 0)
				jm_rt_vertexInput.transform = jm_rt_vertexInput.transform * jm_rt_weights.x + jm_rt_B.transform * jm_rt_weights.y + jm_rt_C.transform * jm_rt_weights.z;

			if (JM_RT_objectData.vertexInput.vertexNormal.buffId == 0)
				jm_rt_vertexInput.normal = normalize(cross(jm_rt_C.position - jm_rt_vertexInput.position, jm_rt_B.position - jm_rt_vertexInput.position));
			else jm_rt_vertexInput.normal = normalize(jm_rt_vertexInput.normal * jm_rt_weights.x + jm_rt_B.normal * jm_rt_weights.y + jm_rt_C.normal * jm_rt_weights.z);
			
			{
				const mat3 jm_tangentTransform = Jimara_CalculateTangentSpaceTransform(
					jm_rt_vertexInput.normal, 
					jm_rt_vertexInput.position, jm_rt_B.position, jm_rt_C.position, 
					jm_rt_vertexInput.uv, jm_rt_B.uv, jm_rt_C.uv);
				jm_rt_InitMaterialState_tangent = jm_tangentTransform[0];
				jm_rt_InitMaterialState_bitangent = jm_tangentTransform[1];
			}
#if (JM_MaterialFlags & JM_UseTangents) != 0
			jm_rt_vertexInput.tangent = jm_rt_InitMaterialState_tangent;
			jm_rt_vertexInput.bitangent = jm_rt_InitMaterialState_bitangent;
#endif
			{
				const vec3 jm_rt_posA = (jm_rt_vertexInput.transform * vec4(jm_rt_vertexInput.position, 1.0)).xyz;
				const vec3 jm_rt_posB = (jm_rt_vertexInput.transform * vec4(jm_rt_B.position, 1.0)).xyz;
				const vec3 jm_rt_posC = (jm_rt_vertexInput.transform * vec4(jm_rt_C.position, 1.0)).xyz;
				jm_rt_InitMaterialState_tangent = normalize(jm_rt_vertexInput.transform * vec4(jm_rt_InitMaterialState_tangent, 0.0)).xyz;
				jm_rt_InitMaterialState_bitangent = normalize(jm_rt_vertexInput.transform * vec4(jm_rt_InitMaterialState_bitangent, 0.0)).xyz;
				vec2 jm_rt_bar = JM_RT_CalculateBarycentrics(
					jm_rt_posA, jm_rt_posB, jm_rt_posC, 
					jm_rt_posA + jm_rt_InitMaterialState_tangent);
				jm_rt_InitMaterialState_tangent *= 
					length(jm_rt_vertexInput.uv * (-jm_rt_bar.x - jm_rt_bar.y) + jm_rt_B.uv * jm_rt_bar.x + jm_rt_C.uv * jm_rt_bar.y);
				jm_rt_bar = JM_RT_CalculateBarycentrics(
					jm_rt_posA, jm_rt_posB, jm_rt_posC, 
					jm_rt_posA + jm_rt_InitMaterialState_bitangent);
				jm_rt_InitMaterialState_bitangent *= 
					length(jm_rt_vertexInput.uv * (-jm_rt_bar.x - jm_rt_bar.y) + jm_rt_B.uv * jm_rt_bar.x + jm_rt_C.uv * jm_rt_bar.y);
			}

			jm_rt_vertexInput.position = jm_rt_vertexInput.position * jm_rt_weights.x + jm_rt_B.position * jm_rt_weights.y + jm_rt_C.position * jm_rt_weights.z;
			jm_rt_vertexInput.uv = jm_rt_vertexInput.uv * jm_rt_weights.x + jm_rt_B.uv * jm_rt_weights.y + jm_rt_C.uv * jm_rt_weights.z;
			
#if ((JM_MaterialFlags & JM_UseVertexColor) != 0)
			jm_rt_vertexInput.vertexColor = jm_rt_vertexInput.vertexColor * jm_rt_weights.x + jm_rt_B.vertexColor * jm_rt_weights.y + jm_rt_C.vertexColor * jm_rt_weights.z;
#endif
#if ((JM_MaterialFlags & JM_UsePerVertexTilingAndOffset) != 0)
			jm_rt_vertexInput.tilingAndOffset = jm_rt_vertexInput.tilingAndOffset * jm_rt_weights.x + jm_rt_B.tilingAndOffset * jm_rt_weights.y + jm_rt_C.tilingAndOffset * jm_rt_weights.z;
#endif
		}

		// Calculate cone-based position and UV derivatives:
		{
			const vec3 hitPoint = (jm_rt_vertexInput.transform * vec4(jm_rt_vertexInput.position, 1.0)).xyz;
			JM_RT_CalculateConeHit(
				jimara_RayTracedRenderer_Call_Payload.eyePosition,
				hitPoint,
				normalize((jm_rt_vertexInput.transform * vec4(jm_rt_vertexInput.normal, 0.0)).xyz),
				jimara_RayTracedRenderer_Call_Payload.startPatchSize,
				jimara_RayTracedRenderer_Call_Payload.patchSizeOverDistance,
				jm_rt_dP_x, jm_rt_dP_y);
			jm_rt_dUV_x = vec2(dot(jm_rt_dP_x, jm_rt_InitMaterialState_tangent), dot(jm_rt_dP_x, jm_rt_InitMaterialState_bitangent));
			jm_rt_dUV_y = vec2(dot(jm_rt_dP_y, jm_rt_InitMaterialState_tangent), dot(jm_rt_dP_y, jm_rt_InitMaterialState_bitangent));
		}

		JM_RT_materialProperties = JM_RT_MaterialPropertiesBuffer(nonuniformEXT(JM_RT_objectData.materialSettingsBufferId)).value;
		JM_RT_fragmentData = JM_EvaluateVertex(jm_rt_vertexInput, JM_RT_materialProperties);
	}


#if (JM_MaterialFlags & JM_CanDiscard) != 0
	return
#endif
	JM_Init(JM_RT_fragmentData, JM_RT_materialProperties, JM_RT_shadingState);
	
#if (JM_MaterialFlags & JM_CanDiscard) == 0
	return true;
#endif
}

#endif
