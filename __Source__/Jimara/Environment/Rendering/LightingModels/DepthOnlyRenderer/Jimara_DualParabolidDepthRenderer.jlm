
layout(set = MODEL_BINDING_SET_ID, binding = MODEL_BINDING_START_ID) uniform Jimara_DualParaboloidDepthRenderer_ViewportBuffer {
	vec3 viewOffset;
	float closePlane;
	float farPlane;
	float forward;
	float clipEpsilon;
} jimara_DualParaboloidDepthRenderer_ViewportBuffer;

/** ############################################ VERTEX SHADER: ############################################ */
#ifdef JIMARA_VERTEX_SHADER

// Vertex output:
//layout(location = 0) out float Jimara_ParaboloidDepthRenderer_clipDepth;
layout(location = 0) out Jimara_FragmentInput Jimara_ParaboloidDepthRenderer_fragment;

void main() {
	Jimara_FragmentInput fragInput = Jimara_CalculateFragmentInput();
	float forward = jimara_DualParaboloidDepthRenderer_ViewportBuffer.forward;

	vec3 position = (fragInput.position + jimara_DualParaboloidDepthRenderer_ViewportBuffer.viewOffset) * vec3(forward, 1.0, forward);
	float depth = length(position);
	vec3 direction = position / depth;
	float scaleAmount = (1.0 / (direction.z + 1.0));

	// depth = (closePlane * farPlane) / (farPlane + clipSpaceDepth * (closePlane - farPlane)) => 
	// => depth * (farPlane + clipSpaceDepth * (closePlane - farPlane)) = (closePlane * farPlane) =>
	// => clipSpaceDepth = ((closePlane * farPlane) / depth - farPlane) / (closePlane - farPlane);
	
	float closePlane = jimara_DualParaboloidDepthRenderer_ViewportBuffer.closePlane;
	float farPlane = jimara_DualParaboloidDepthRenderer_ViewportBuffer.farPlane;
	float clipSpaceDepth = (farPlane - (closePlane * farPlane) / depth) / (farPlane - closePlane);

	gl_Position = vec4(
		((direction.x * scaleAmount) - forward) * 0.5f, // This puts 'front' image on left and 'back' image on right
		direction.y * scaleAmount,
		clipSpaceDepth,
		1.0);
	//Jimara_ParaboloidDepthRenderer_clipDepth = direction.z;
	Jimara_ParaboloidDepthRenderer_fragment = fragInput;
}

#endif

/** ############################################ FRAGMENT SHADER: ############################################ */
#ifdef JIMARA_FRAGMENT_SHADER

// Fragment input:
//layout(location = 0) in float Jimara_ParaboloidDepthRenderer_clipDepth;
layout(location = 0) in Jimara_FragmentInput Jimara_ParaboloidDepthRenderer_fragment;

void main() {
	//if (Jimara_ParaboloidDepthRenderer_clipDepth < 0.0) discard;
	//vec2 clipUV = Jimara_ParaboloidDepthRenderer_uv;
	{
		float forward = jimara_DualParaboloidDepthRenderer_ViewportBuffer.forward;
		float fragmentZ = Jimara_ParaboloidDepthRenderer_fragment.position.z;
		float posZ = jimara_DualParaboloidDepthRenderer_ViewportBuffer.viewOffset.z;
		float clipEpsilon = jimara_DualParaboloidDepthRenderer_ViewportBuffer.clipEpsilon;
		if (((fragmentZ + posZ) * forward) < clipEpsilon)
			discard;
	}
	//if ((clipUV.x * forward) > 0) discard;
	//vec2 sideUV = vec2(clipUV.x * 2.0 + forward, clipUV.y);
	//if (dot(sideUV, sideUV) < 1.0) {
	//	float posZ = jimara_DualParaboloidDepthRenderer_ViewportBuffer.viewOffset.z;
	//	float closePlane = jimara_DualParaboloidDepthRenderer_ViewportBuffer.closePlane;
	//	if (((Jimara_ParaboloidDepthRenderer_fragment.position.z + posZ) * forward) < -closePlane)
	//		discard;
	//}
	Jimara_GeometryBuffer gbuffer = Jimara_BuildGeometryBuffer(Jimara_ParaboloidDepthRenderer_fragment);
}
#endif
