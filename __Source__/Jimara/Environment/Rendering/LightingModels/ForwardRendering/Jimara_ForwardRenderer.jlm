
layout(set = MODEL_BINDING_SET_ID, binding = MODEL_BINDING_START_ID) uniform Jimara_ForwardRenderer_ViewportBuffer {
	mat4 view;
	mat4 projection;
} jimara_ForwardRenderer_ViewportBuffer;

mat4 Jimara_ViewMatrix() { 
	return jimara_ForwardRenderer_ViewportBuffer.view;
}

mat4 Jimara_ProjectionMatrix() { 
	return jimara_ForwardRenderer_ViewportBuffer.projection;
}

mat4 Jimara_CameraTransform() {
	return jimara_ForwardRenderer_ViewportBuffer.projection * jimara_ForwardRenderer_ViewportBuffer.view;
}

/** ############################################ VERTEX SHADER: ############################################ */
#ifdef JIMARA_VERTEX_SHADER

// Vertex output:
layout(location = 0) out Jimara_FragmentInput ForwardRenderer_fragment;

void main() {
	Jimara_FragmentInput fragInput = Jimara_CalculateFragmentInput();
	gl_Position = Jimara_CameraTransform() * vec4(fragInput.position.xyz, 1.0f);
	ForwardRenderer_fragment = fragInput;
}

#endif

/** ############################################ FRAGMENT SHADER: ############################################ */
#ifdef JIMARA_FRAGMENT_SHADER

// Light type identifiers
layout(std430, set = MODEL_BINDING_SET_ID, binding = (MODEL_BINDING_START_ID + 1)) buffer Jimara_ForwardRenderer_LightTypeIds { 
	uint ids[]; 
} jimara_ForwardRenderer_LightTypeIds;

// Light grid:
#define SCENE_LIGHT_GRID_BINDING_SET MODEL_BINDING_SET_ID
#define SCENE_LIGHT_GRID_BINDING_START_ID (MODEL_BINDING_START_ID + 2)
#include <Environment/Rendering/SceneObjects/Lights/SceneLightGrid.glh>

// Fragment input:
layout(location = 0) in Jimara_FragmentInput ForwardRenderer_fragment;

// Result
layout(location = 0) out vec4 outColor;

void Jimara_FragmentInput_Illuminate(inout Jimara_GeometryBuffer gbuffer, in HitPoint hit, in SceneLightGrid_VoxelRange lightVoxelRange) {
	const uint localLightCount = SceneLightGrid_GetLightCount(lightVoxelRange);
	for (uint id = 0; id < localLightCount; id++) {
		const uint i = SceneLightGrid_GetLightIndex(lightVoxelRange, id);
		uint typeId = jimara_ForwardRenderer_LightTypeIds.ids[i];
		Photon photons[MAX_PER_LIGHT_SAMPLES];
		uint photonCount = Jimara_GetLightSamples(i, typeId, hit, photons);
		for (uint j = 0; j < photonCount; j++)
			Jimara_IlluminateFragment(photons[j], gbuffer);
	}
}

void main() {
	Jimara_GeometryBuffer gbuffer = Jimara_BuildGeometryBuffer(ForwardRenderer_fragment);
	HitPoint hit;
	hit.position = gbuffer.position;
	hit.normal = gbuffer.normal;
	
	//*
	SceneLightGrid_IlluminatingVoxels voxels;
	SceneLightGrid_GetIlluminatingVoxels(hit.position, voxels);
	#pragma unroll SceneLightGrid_PerPointRangeCount
	for (uint i = 0; i < SceneLightGrid_PerPointRangeCount; i++)
		Jimara_FragmentInput_Illuminate(gbuffer, hit, voxels[i]);
	/*/
	for (uint i = 0; i < jimara_ForwardRenderer_LightTypeIds.ids.length(); i++) {
		uint typeId = jimara_ForwardRenderer_LightTypeIds.ids[i];
		Photon photons[MAX_PER_LIGHT_SAMPLES];
		uint photonCount = Jimara_GetLightSamples(i, typeId, hit, photons);
		for (uint j = 0; j < photonCount; j++)
			Jimara_IlluminateFragment(photons[j], gbuffer);
	}
	//*/
	outColor = gbuffer.pixelColor;
}
#endif
