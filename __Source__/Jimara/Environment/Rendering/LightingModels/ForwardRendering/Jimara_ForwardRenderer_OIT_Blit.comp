#version 450
#extension GL_EXT_shader_image_load_formatted: require

layout(set = 0, binding = 0) uniform Settings {
	uvec2 frameBufferSize;
	uint fragsPerPixel;
} settings;

struct PixelState {
	uint lock;
	uint fragmentCount;
};
layout(set = 0, binding = 1) buffer readonly ResultBufferPixels {
	PixelState state[];
} resultBufferPixels;

struct FragmentInfo {
	float depth;
	uint packedRG; // Color is stored premultiplied
	uint packedBA; // Instead of alpha, we store transmittance (1 - a) for transparent and 1 for additive
};
layout(set = 0, binding = 2) buffer readonly FragmentData {
	FragmentInfo fragments[];
} fragmentData;

layout(set = 0, binding = 3) uniform image2D colorAttachment;

//layout(set = 0, binding = 4) uniform image2D depthAttachment;

#define BLOCK_SIZE 16
layout(local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = 1) in;

void main() {
	const ivec2 pixelIndex = ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y));
	if (pixelIndex.x >= settings.frameBufferSize.x || pixelIndex.y >= settings.frameBufferSize.y)
		return;

	const uint pixelBufferIndex = pixelIndex.y * settings.frameBufferSize.x + pixelIndex.x;
	const PixelState pixelInfo = resultBufferPixels.state[pixelBufferIndex];
	if (pixelInfo.fragmentCount <= 0)
		return;

	vec4 color = imageLoad(colorAttachment, pixelIndex);
	color.rgb *= color.a;

	const uint fragmentStartIndex = pixelBufferIndex * settings.fragsPerPixel;
	uint fragmentIndex = (fragmentStartIndex + pixelInfo.fragmentCount);
	while (fragmentIndex > fragmentStartIndex) {
		fragmentIndex--;
		const FragmentInfo fragment = fragmentData.fragments[fragmentIndex];
		vec4 fragColor;
		fragColor.rg = unpackHalf2x16(fragment.packedRG);
		fragColor.ba = unpackHalf2x16(fragment.packedBA);
		color.rgb = color.rgb * fragColor.a + fragColor.rgb;
		color.a = 1 - (1 - color.a) * fragColor.a;
	}

	if (color.a > 0.000001)
		color.rgb /= color.a;
	
	imageStore(colorAttachment, pixelIndex, color);
	//imageStore(depthAttachment, pixelIndex, vec4(fragmentData.fragments[fragmentIndex].depth, 0.0, 0.0, 1.0));
}
