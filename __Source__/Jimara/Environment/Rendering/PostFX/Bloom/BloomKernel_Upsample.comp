#version 450
#define BLOCK_SIZE 16
layout(local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D smallMip;
layout(set = 0, binding = 1) uniform writeonly image2D result;
layout(set = 0, binding = 2, rgba16f) uniform readonly image2D bigMip;
layout(set = 0, binding = 3) uniform Params {
	float spread;
    float strenght;
} params;

void main() {
    ivec2 coord = ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y));
    ivec2 resolution = imageSize(result).xy;

    if (coord.x >= resolution.x || coord.y >= resolution.y) return;

    vec2 uvStep = vec2(
        1.0 / float(resolution.x), 
        1.0 / float(resolution.y));

    vec2 uv = vec2(
		uvStep.x * (float(coord.x) + 0.5), 
		uvStep.y * (float(coord.y) + 0.5));

    uvStep *= params.spread;

    const float CORNER = 0.0625;    // 1 / 16;
    const float CROSS = 0.125;      // 2 / 16;
    const float CENTER = 0.25;      // 4 / 16;

    vec4 color = texture(smallMip, uv) * CENTER;

    color += (
        texture(smallMip, uvStep * vec2(-1.0, -1.0) + uv) +
        texture(smallMip, uvStep * vec2(1.0, -1.0) + uv) +
        texture(smallMip, uvStep * vec2(-1.0, 1.0) + uv) +
        texture(smallMip, uvStep * vec2(1.0, 1.0) + uv)) * CORNER;

    color += (
        texture(smallMip, uvStep * vec2(-1.0, 0.0) + uv) +
        texture(smallMip, uvStep * vec2(1.0, 0.0) + uv) +
        texture(smallMip, uvStep * vec2(0.0, -1.0) + uv) +
        texture(smallMip, uvStep * vec2(0.0, 1.0) + uv)) * CROSS;

    vec4 baseColor = imageLoad(bigMip, coord);
    vec3 mixRGB = mix(baseColor.rgb, color.rgb, params.strenght);
    imageStore(result, coord, vec4(mixRGB, baseColor.w));
}
