#define BLOCK_SIZE 256
layout(local_size_x = BLOCK_SIZE, local_size_y = 1, local_size_z = 1) in;

#include "../../Algorithms/BinarySearch.glh"

struct Jimara_CombinedParticleKernel_TaskDescriptor {
	ParticleTaskSettings taskSettings;
	uvec4 taskBoundaries;
};

layout (set = COMBINED_PARTICLE_KERNEL_BINDING_SET, binding = COMBINED_PARTICLE_KERNEL_BINDING) buffer readonly Jimara_CombinedParticleKernelTasks {
	Jimara_CombinedParticleKernel_TaskDescriptor[] descriptors;
} jimara_CombinedParticleKernelTasks;

void main() {
	const uint threadIndex = uint(gl_GlobalInvocationID.x);

	// Calculate task index:
	uint taskIndex;
	{
		const uint taskCount = jimara_CombinedParticleKernelTasks.descriptors.length();
		const uint minEndIndex = (threadIndex + 1);
		#define Jimara_BinarySearch_IS_LESS_THAN(index) (jimara_CombinedParticleKernelTasks.descriptors[index].taskBoundaries.y > minEndIndex)
		Jimara_BinarySearch_LE(jimara_CombinedParticleKernelTasks.descriptors.length(), taskIndex, Jimara_BinarySearch_IS_LESS_THAN);
		#undef Jimara_BinarySearch_IS_LESS_THAN
		
		// If we got an out of bounds result, every endThreadIndex is greater than minEndIndex and therefore, index 0 will work just fine:
		if (taskIndex >= taskCount) taskIndex = 0;

		// Otherwise, we either found minEndIndex or resultTaskIndex is the index of the last element that is less than minEndIndex:
		else if (jimara_CombinedParticleKernelTasks.descriptors[taskIndex].taskBoundaries.y < minEndIndex) {
			taskIndex++;
			if (taskIndex >= taskCount) return;
		}
	}

	// Execute kernel:
	{
		Jimara_CombinedParticleKernel_TaskDescriptor taskDescriptor = jimara_CombinedParticleKernelTasks.descriptors[taskIndex];
		const uint particleId = (threadIndex - taskDescriptor.taskBoundaries.x);
		UpdateParticle(taskDescriptor.taskSettings, particleId);
	}
}
