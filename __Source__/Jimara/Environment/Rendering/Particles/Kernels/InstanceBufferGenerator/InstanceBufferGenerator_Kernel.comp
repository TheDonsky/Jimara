#version 450
#extension GL_EXT_nonuniform_qualifier : enable

#include "../../ParticleState.glh"
#include "../../../../../Math/Math.glh"

struct SimulationTaskSettings {
	mat4 baseTransform;					// Bytes [0 - 64)
	uint particleIndirectionBufferId;	// Bytes [64 - 68)
	uint particleStateBufferId;			// Bytes [68 - 72)
	uint instanceBufferId;				// Bytes [72 - 76)
	uint instanceStartId;				// Bytes [76 - 80)
	uint taskThreadCount;				// Bytes [80 - 84)
	uint liveParticleCountBufferId;		// Bytes [84 - 88)
	uint pad_0, pad_1;					// Bytes [88 - 96)
};

layout (set = 0, binding = 0) buffer StateBuffers {
    ParticleState[] state;
} stateBuffers[];

layout (set = 0, binding = 0) buffer IndirectionBuffers {
	uint[] indices;
} indirectionBuffers[];

layout (set = 0, binding = 0) buffer LiveCountBuffers {
    uint[] count;
} liveCountBuffers[];

layout (set = 0, binding = 0) buffer ResultBuffers {
    mat4[] pose;
} resultBuffers[];

mat4 GetInstanceTransform(in ParticleState state, in SimulationTaskSettings settings) {
	return settings.baseTransform * Jimara_TransformMatrix(state.position, state.eulerAngles, state.size);
}

mat4 GetInstanceTransform(in SimulationTaskSettings settings, uint particleIndex) {
	if (liveCountBuffers[settings.liveParticleCountBufferId].count[0] <= particleIndex) return mat4(0.0);
	const uint indirectParticleId = indirectionBuffers[settings.particleIndirectionBufferId].indices[particleIndex];
	return GetInstanceTransform(stateBuffers[settings.particleStateBufferId].state[indirectParticleId], settings);
}

void ExecuteSimulationTask(in SimulationTaskSettings settings, uint particleIndex) {
	resultBuffers[settings.instanceBufferId].pose[settings.instanceStartId + particleIndex] = GetInstanceTransform(settings, particleIndex);
}

#define COMBINED_SIMULATION_KERNEL_BINDING_SET 1
#define COMBINED_SIMULATION_KERNEL_BINDING 0
#include "../../../../GraphicsSimulation/CombinedGraphicsSimulationKernel_Body.glh"
